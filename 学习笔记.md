# 1. 异步

## 1.1 async await 基本使用

异步方法不等于多线程，await是等但又是不等。

### 1.1.1 调用系统的async方法

```C#
static async Task Main(string[] args)
{
    await File.WriteAllTextAsync("a.txt", "xxxxxxxxxx");
    string s = await File.ReadAllTextAsync("a.txt");
    Console.WriteLine(s);
}
```

> 使用await关键字调用async方法，await表示等待`await File.WriteAllTextAsync("a.txt", "xxxxxxxxxx");`执行到这里时，如果这句话没执行完成，后面的代码不会运行。

- 如果方法中使用了await关键字，则方法必须改为async修饰的方法。
- Main 函数使用async修饰后，返回值要改成Task
- 如果是winform里面的按钮或其他事件用async修饰后，返回值不需要修改为Task
- 返回值代表的意思：Task=void；Task=int；Task=string

### 1.1.2 不使用await调用系统的async方法

```C#
static void Main(string[] args)
{
    // 调用无返回值使用wait方法
    File.WriteAllTextAsync("a.txt", "xxxxxxxxxx").Wait();
    // 调用有返回值使用Result属性
    string s = File.ReadAllTextAsync("a.txt").Result;
    Console.WriteLine(s);
}
```

### 1.1.3 使用Delay实现sleep等延时等待效果

- 在多线程中，如果需要等待几秒后再执行，则需要使用`Thread.Sleep(1000);`来等待，但是这个函数会造成主线程堵塞，将系统卡住，等计时结束才会重新恢复系统。而使用`await Task.Delay(1000)`则不会造成系统堵塞。

```C#
static async Task Main(string[] args)
{

    Console.WriteLine("1");
    await mm("aa");
    Console.WriteLine("2");
}
static async Task mm(string n)
{
    Console.WriteLine(n + "开始");
    await Task.Delay(5000);
    Console.WriteLine(n + "结束");
}
```

上述代码的执行结果是：

```undefined
1
aa开始
等待5000毫秒后。。。
aa结束
2
```

### 1.1.4 线程池中使用async

```C#
static void Main(string[] args)
{
    ThreadPool.QueueUserWorkItem(async (obj) =>
    {
        while (true)
        {
            Console.WriteLine("xxxxxxxxxxxx");
        }
    });
    Console.ReadLine();
}
```

> 因为只是在方法中使用了async所以不需要将方法用async修饰，方法的返回值也不需要修改为Task，只有方法中用到了await才需要使用async修饰方法。

## 1.2 使用Task执行异步操作

### 1.2.1 为什么要使用 Task

线程是创建并发的底层工具，因此具有一定的局限性。

- 没有简单的方法可以从联合（Join）线程得到“返回值”。因此必须创建一些共享域。当抛出一个异常时，捕捉和处理异常也是麻烦的。
- 线程完成之后，无法再次启动该线程。相反，只能联合（Join）它（在进程阻塞当前线程）。

任务是可组合的——使用延续将它们串联在一起。它们可以使用线程池减少启动延迟，而且它们可以通过`TaskCompletionSource`使用回调方法，避免多个线程同时等待I/O密集操作。

### 1.2.2 Task 和 Thread 区别

1、任务是架构在线程之上的，也就是说任务最终还是要抛给线程去执行。

2、任务跟线程不是一对一的关系，比如开10个任务并不是说会开10个线程，这一点任务有点类似线程池，但是任务相比线程池有很小的开销和精确的控制。

Task和Thread一样，位于`System.Threading`命名空间下

与线程相比，`Task`是一个更高级的抽象概念，它标识一个通过或不通过线程实现的并发操作。

### 1.2.3 Task 介绍

Task 类的表示单个操作不返回一个值，通常以异步方式执行。 Task 对象是一个的中心思想 基于任务的异步模式 首次引入.NET Framework 4 中。 因为由执行工作 Task 对象通常以异步方式执行在线程池线程上而不是以同步方式在主应用程序线程，您可以使用 Status 属性，以及 IsCanceled, ，IsCompleted, ，和 IsFaulted 属性，以确定任务的状态。 大多数情况下，lambda 表达式用于指定的任务是执行的工作。

### 1.2.4 Task 简单实现

通过使用Task的构造函数来创建任务，并调用Start方法来启动任务并执行异步操作。

```C#
static void Main(string[] args)
{
        Console.WriteLine("主线程执行业务处理.");
        //创建任务
        Task task = new Task(() => {
            Console.WriteLine("使用System.Threading.Tasks.Task执行异步操作.");
            for (int i = 0; i < 10; i++)
            {
                  Console.WriteLine(i);
            }
      });
     //启动任务,并安排到当前任务队列线程中执行任务
      task.Start();
      Console.WriteLine("主线程执行其他处理");
}
```

从Framework 4.5开始，启动一个由后台线程实现的Task，也可以使用静态方法 Task.Run

```C#
Task task = Task.Run(() =>
    {
        Thread.Sleep(2000);
        Console.WriteLine("Foo");
    });
```

> Task默认使用线程池，它们都是后台线程。意味当主线程结束时，所有任务都会随之停止

### 1.2.5 Task 执行状态

#### 1) 等待（Wait）

调用`Wait`方法，可以阻塞任务，直至任务完成，效果等同于`Thread.Join`：

```c#
    Task task = Task.Run(() =>
    {
        Thread.Sleep(2000);
        Console.WriteLine("Foo");
    });
    Console.WriteLine(task.IsCompleted); //False
    task.Wait();//阻塞，直至任务完成
    Console.WriteLine(task.IsCompleted); //True
    Console.ReadLine();
```

#### 2) 返回值

`Task<TResult>`允许任务返回一个值。调用`Task.Run`，传入一个`Func<TResult>`代理（或者兼容的Lambda表达式），代替Action，就可以获得一个Task<TResult>：

```C#
Task<int> task = Task.Run (() => { Console.WriteLine ("Foo"); return 3; });

int result = task.Result;      // Blocks if not already finished
Console.WriteLine (result);    // 3
```

下面的例子创建一个任务，它使用LINQ就按前3百万个整数（从2开始）中的素数个数：

```C#
Task<int> primeNumberTask = Task.Run(() =>
        Enumerable.Range(2, 3000000).Count(n => Enumerable.Range(2, (int)Math.Sqrt(n) - 1).All(i => n % i > 0)));

    Console.WriteLine("Task running...");
    Console.WriteLine("The answer is " + primeNumberTask.Result);
```

这段代码会打印“Task running...”，然后几秒钟后打印216815。

#### 3) Task.Delay

`Task.Delay`是`Thread.Sleep`的异步版本

```C#
Task.Delay(5000).GetAwaiter().OnCompleted(()=>Console.WriteLine(42));
```

或者

```C#
Task.Delay(5000).ContinueWith(ant => Console.WriteLine(42));
```

### 1.2.6 取消Task任务

> 在用await执行方法时，方法有时候会执行特别长时间，在执行过程中想中断方法，需要使用到 `CancellationToken`类。

#### 1) 控制台程序中取消Task任务

一、 创建一个执行需要很长时间的方法

```C#
static async Task DownloadAsync(string url, int n,
	CancellationToken cancellationToken)
{
    using (HttpClient client = new HttpClient())
    {
        for (int i = 0; i < n; i++)
        {
            string html = await client.GetStringAsync(url);
            Console.WriteLine($"{DateTime.Now}：{html}");
            // 判断请求是否被取消，如果被取消则直接取消请求
            if (cancellationToken.IsCancellationRequested)
            {
                Console.WriteLine("请求取消");
                break;
            }
        }
    }
}
```

  `cancellationToken.IsCancellationRequested` 返回的是一个bool值，表示当前Task任务有没有被取消。
  也可以使用`cancellationToken.ThrowIfCancellationRequested()`这个方法表示如果Task任务被取消了的话，直接抛出一个异常。调用的函数需要处理这个异常
  如果调用的.net内部函数可以传递 `CancellationToken`的话就在调用时将 `CancellationToken`传递给内部函数，防止内部函数执行的时间过长，导致定时取消不准确。

#### 2) 在调用时传递CancellationToken用来取消Task任务

定时取消任务：

```C#
static async Task Main(string[] args)
{
    CancellationTokenSource cts = new CancellationTokenSource();
    // 执行方法超过2000毫秒的时候取消执行此方法
    cts.CancelAfter(2000);
    CancellationToken token = cts.Token;
    await DownloadAsync("https://www.baidu.com", 50, token);

}
```

自定义条件取消任务

```C#
static void Main(string[] args)
{
    CancellationTokenSource cts = new CancellationTokenSource();
    CancellationToken token = cts.Token;
    DownloadAsync("https://www.baidu.com", 50, token);
    while (Console.ReadLine() != "q")
    {

    }
    cts.Cancel();
    Console.ReadLine();
}
```

#### 3) 在web网页中取消Task任务

##### 一、耗时的方法

```C#
static async Task DownloadAsync(string url, int n, 
	CancellationToken cancellationToken)
{
	using (HttpClient client = new HttpClient())
	{
		for (int i = 0; i < n; i++)
		{
			string html = await client.GetStringAsync(url);
			Debug.WriteLine($"{DateTime.Now}：{html}");
			//判断请求是否被取消，如果被取消则直接取消请求
			if (cancellationToken.IsCancellationRequested)
			{
				Debug.WriteLine("请求取消");
				break;
			}
		}
	}
}
```

##### 二、浏览器关闭时，取消Task任务

```C#
public async Task<IActionResult> Index(CancellationToken token)
{
    await Downloa1dAsync("https://www.baidu.com", 5000, token);
    return View();
}
```

> 在控制器中.net会自动注入 `CancellationToken`，只需要直接用就可以，取消的时机为浏览器关闭或者用户不再访问当前页面时。

## 1.3 使用yield返回集合数据

使用yield能将返回值一个一个返回回去，然后接收的地方先进行处理，处理完，等下一个返回值回来后再处理下一个。

```C#
static void Main(string[] args)
{
    foreach (var arg in GetStrings())
    {
        Console.WriteLine(arg);
    }
    Console.ReadLine();
}

static IEnumerable<string> GetStrings()
{
   yield return "1";
    Console.WriteLine("1返回去了");
   yield return "2";
    Console.WriteLine("2返回去了");
    yield return "3";
    Console.WriteLine("3返回去了");
}
```

执行结果：

```C#
1
1返回去了
2
2返回去了
3
3返回去了
```

**在async修饰的方法中使用yield**

则返回值类型改为 `IAsyncEnumerable`

```C#
static async Task Main(string[] args)
{
    await foreach (var arg in  GetStrings())
    {
        Console.WriteLine(arg);
    }
    Console.ReadLine();
}

static async IAsyncEnumerable<string> GetStrings()
{
   yield return "1";
    Console.WriteLine("1返回去了");
   yield return "2";
    Console.WriteLine("2返回去了");
    yield return "3";
    Console.WriteLine("3返回去了");
}
```

## 1.4 异步编程WhenAll 和 WaitAll

如果有多个Task任务，如果需要等待所有任务执行完成使用：`WaitAll`或 `WhenAll`
如果只需要等待其中一个执行完成则使用 `WaitAny`或 `WhenAny`
When表示有返回值
Wait表示无返回值

```C#
static async Task Main(string[] args)
{
    Console.WriteLine("无返回值开始");
    Task.WaitAll(NoResult(5000),NoResult(3000));
    Console.WriteLine("无返回值都执行完了");

    Console.WriteLine("有返回值开始");
    Task<int>[] ints1 = new Task<int>[2];
    ints1[0] = BeResult(3000);
    ints1[1] = BeResult(5000);
    int[] ints = await Task.WhenAll(ints1);
    foreach (int i in ints)
    {
        Console.WriteLine(i);
    }
    Console.WriteLine("有返回值都执行完了");
    Console.ReadLine();
}

static async Task NoResult(int n)
{
    await Task.Delay(n);
    Console.WriteLine($"延时{n}执行完了");

}
static async Task<int> BeResult(int n)
{

    await Task.Delay(n);
    Console.WriteLine($"延时{n}执行完了");
    return n;
}
```

执行结果：

```yaml
无返回值开始
延时3000执行完了
延时5000执行完了
无返回值都执行完了
有返回值开始
延时3000执行完了
延时5000执行完了
3000
5000
有返回值都执行完了
```

# 2. LINQ 表达式

## 2.1 委托演变lambda

委托可以演变为匿名方法，然后由匿名方法演变成为Lambda。

```C#
static void MM(string[] args)
{
    // 无参数无返回值的匿名方法
    Action a1 = delegate ()
    {
        Console.WriteLine("这是一个匿名方法");
    };
    a1();
    // 有参数无返回值的匿名方法
    Action<string, string> a2 = delegate (string s, string t)
    {
        Console.WriteLine($"s={s},t={t}");
    };
    a2("1","2");
    // 有参数有返回值的匿名方法
    Func<int, int, int> f1 = delegate (int x, int y)
    {
        return x + y;
    };
    Console.WriteLine(f1(1, 2));

    // 有参数有返回值的匿名方法 缩写1 省略delegate 改为 =>
    Func<int, int, int> f2 = (int x, int y) =>
    {
        return x + y;
    };
    Console.WriteLine(f2(1, 2));

    // 有参数有返回值的匿名方法 缩写2 代码有返回值并且只有一行代码，省略{}和return
    Func<int, int, int> f3 = (int x, int y) => x + y;
    Console.WriteLine(f3(1, 2));

    // 有参数有返回值的匿名方法 缩写3 参数列表的类型是可以省略的
    Func<int, int, int> f4 = (x, y) => x + y;
    Console.WriteLine(f4(1, 2));


    // 无参数无返回值的匿名方法 缩写1 无参数无返回值省略{}
    Action s1 = () =>  Console.WriteLine("这是一个匿名方法 缩写形式");
    s1();

    // 有参数无返回值的匿名方法 缩写2 有一个参数无返回值省略{}和()
    Action<string> s2 = x => Console.WriteLine($"{x}");
    s2("fdsaf");


}
```

## 2.2 LINQ 常用方法

### 1) 自定义Where方法

```C#
static void MM(string[] args)
{
    IEnumerable<int> ints = new int[] { 1, 2, 4, 63, 12, 34, 46, 12, 45, 12456 };
    // 使用LINQ中的Where方法
    //IEnumerable<int> ints2 = ints.Where(a => a > 10);
    // 使用自定义的Where方法
    IEnumerable<int> ints2 = MyWhere(ints, a => a > 10);
    foreach (int i in ints2)
    {
        Console.WriteLine(i);
    }
}
// 自定义的Where方法
static IEnumerable<int> MyWhere(IEnumerable<int> ints,Func<int,bool> f)
{
    List<int> list = new List<int>();
    foreach (int i in ints)
    {
        if (f(i))
        {
            yield return i;
        }
    }
}
```

### 2) 常用的方法

#### 2.1 初始化数据集合

```C#
List<Employee> employees = new List<Employee>();
list.Add(new Employee(){Id = 1,Name = "张三",Age = 16,Gender = false,Salary = 2000});
list.Add(new Employee(){Id = 2,Name = "凌洋",Age = 32,Gender = false,Salary = 1500});
list.Add(new Employee(){Id = 3,Name = "夏一桐",Age = 11,Gender = true,Salary = 4000});
list.Add(new Employee(){Id = 4,Name = "崔今生",Age = 32,Gender = false,Salary = 2000});
list.Add(new Employee(){Id = 5,Name = "孙河",Age = 23,Gender = true,Salary = 5000});
list.Add(new Employee(){Id = 6,Name = "方晴",Age = 26,Gender = true,Salary = 8000});
list.Add(new Employee(){Id = 7,Name = "赵七",Age = 32,Gender = true,Salary = 3000});
list.Add(new Employee(){Id = 8,Name = "包卫丽",Age = 26 ,Gender = true,Salary = 4500});
```

#### 2.2 Where

Where 获取满足条件的数据 返回值：IEnumerable<>集合

```C#
IEnumerable<Employee> employees1 = employees.Where(a => a.Salary > 3000 && a.Age > 30);
foreach (Employee employee in employees1)
{
    Console.WriteLine(employee.ToString());
}
```

#### 2.3 Any

Any 判断集合中是否最少有一条满足他条件的数据 返回值：bool

```C#
Console.WriteLine(employees.Any(a => a.Id > 100));
Console.WriteLine(employees.Any(a => a.Id > 7));
```

#### 2.4 Count

Count 获取集合中满足条件的数量 返回值：int

```C#
Console.WriteLine(employees.Count(a => a.Id > 100));
Console.WriteLine(employees.Count(a => a.Id > 7));
```

#### 2.5 Single

Single 有并且只有一条满足条件的数据，有多条满足条件的数据提示错误，未找到满足条件的数据也会提示错误

```C#
//Employee employee1 = employees.Single(a=>a.Id>1); //报错
//Employee employee1 = employees.Single(a => a.Id == 11); //报错
Employee employee1 = employees.Single(a => a.Id == 1); // 正常
Console.WriteLine(employee1);
```

#### 2.6 SingleOrDefault

SingleOrDefault 最多只有一条满足条件的数据，未找到满足条件的数据返回该数据类型的默认值

```C#
//Employee employee2 = employees.SingleOrDefault(a => a.Id > 1); //报错
//Employee employee2 = employees.SingleOrDefault(a => a.Id == 11); //正常
Employee employee2 = employees.SingleOrDefault(a => a.Id == 1); // 正常
Console.WriteLine(employee2);
```

#### 2.7 First

First 最少有一条满足条件的数据，有多条满足条件的数据返回第一条，未找到满足条件的数据提示错误

```C#
//Employee employee3 = employees.First(a => a.Id > 2); // 正常
//Employee employee3 = employees.First(a => a.Id == 22); // 报错
Employee employee3 = employees.First(a => a.Id == 2); // 正常
Console.WriteLine(employee3);
```

#### 2.8 FirstOrDefault

Where 获取满足条件的数据 返回值：IEnumerable<>集合

```C#
//Employee employee4 = employees.FirstOrDefault(a => a.Id > 2); // 正常
//Employee employee4 = employees.FirstOrDefault(a => a.Id == 22); // 正常
Employee employee4 = employees.FirstOrDefault(a => a.Id == 2); // 正常
Console.WriteLine(employee4);
```

#### 2.9 OrderBy

OrderBy 正序排序

```C#
IEnumerable<Employee> employees2 = employees.OrderBy(a => a.Salary);
foreach (Employee employee in employees2)
{
    Console.WriteLine(employee);
}
```

#### 2.10 OrderByDescending

OrderByDescending 倒序排序

```C#
IEnumerable<Employee> employees3 = employees.OrderByDescending(a => a.Salary);
foreach (Employee employee in employees3)
{
    Console.WriteLine(employee);
}
```

#### 2.11 OrderBy().ThenBy

OrderBy().ThenBy 排序完后再进行小范围的排序

```C#
IEnumerable<Employee> employees4 = employees.OrderBy(a => a.Gender).ThenByDescending(a=>a.Salary).ThenBy(a=>a.Age);
foreach (Employee employee in employees4)
{
    Console.WriteLine(employee);
}
```

#### 2.12 Skip

Skip 跳过多少条数据

```C#
IEnumerable<Employee> employees5 = employees.Where(a=>a.Gender==false).OrderBy(a=>a.Salary).Skip(1);
foreach (Employee employee in employees5)
{
    Console.WriteLine(employee);
}
```

#### 2.13 Take

Take 取几条数据

```C#
IEnumerable<Employee> employees6 = employees.Where(a => a.Gender == false).OrderBy(a => a.Salary).Take(1);
foreach (Employee employee in employees6)
{
    Console.WriteLine(employee);
}
```

#### 2.14 SKip+Take

SKip+Take 跳过几条取几条

```C#
IEnumerable<Employee> employees7 = employees.Where(a => a.Gender == false).OrderBy(a => a.Salary).Skip(1).Take(2);
foreach (Employee employee in employees7)
{
    Console.WriteLine(employee);
}
```

#### 2.15 GroupBy + Max + Min + Average

GroupBy(g=>g) 分组，返回值是IEnumerable<IGrouping<g的类型, g的类型>>类型
Max(g=>g) 获取最大值 返回值是g的类型
Min(g=>g) 获取最小值 返回值是g的类型
Average(g=>g) 获取平均值 返回值是g的类型

```C#
IEnumerable<IGrouping<int, Employee>> employees1 = employees.OrderBy(e=>e.Age).GroupBy(e => e.Age);
foreach (IGrouping<int,Employee> g in employees1)
{
    Console.WriteLine(g.Key);
    Console.WriteLine("分组中的最大工资："+g.Max(e=>e.Salary));
    Console.WriteLine("分组中的最小工资：" + g.Min(e=>e.Salary));
    Console.WriteLine("分组中的平均工资：" + g.Average(e=>e.Salary));
    Console.WriteLine("分组中数量：" + g.Count());
    foreach (Employee e in g)
    {
        Console.WriteLine(e);
    }
}
```

#### 2.16 Select(映射)

Select 映射一种新的类型

```C#
var ls = employees.Select(a => new { XM = a.Name, NL = a.Age, XB = a.Gender ? "男" : "女" });
foreach (var e in ls)
{
    Console.WriteLine(e);
}
```

案例：根据年龄进行分组，获取每组中年龄、最大工资、最小工资、平均工资、和分组个数

```C#
var ls1 = employees.GroupBy(a => a.Age).Select(a => new { 
    Age = a.Key,
    MaxS = a.Max(g => g.Salary),
    MinS = a.Min(g=>g.Salary),
    AvgS = a.Average(g => g.Salary),
    Count = a.Count()
});
foreach (var e in ls1)
{
    Console.WriteLine(e);
}
```

### 3) from 语法

```C#
var chars1 = from c in s
             where char.IsLetter(c)
             select char.ToLower(c);
var chars2 = from c in chars1
             group c by c;
var cc = from c in chars2
         orderby c.Count() descending
         where c.Count() > 2
         select new { dc = c.Key, pl = c.Count() };
```

在from语法中，c叫做范围变量，s是数据源。c的作用域存在于当前的LINQ表达式，表达式以外不能访问这个变量。where用来筛选元素，select用于输出元素。
from 语法需要用select或者group结束。

### 4) 实际应用题

获取字符串中成绩的平均值

```C#
string s = "61,90,100,99,18,22,38,66,80,93,55,50,89";
IEnumerable<string> l = s.Split(",");
Console.WriteLine(l.Average(a=>Convert.ToDouble(a)));
```

统计一个字符串中字母出现的频率（忽略大小写）然后按照从高到低的顺序输出频率高于2次的单词和出现的频率

```C#
string s = "KhKlkKHhfadsf  1111  JHLFDSdaskfjlLKHDSA";
var chars = s.Where(c=>char.IsLetter(c)).Select(c=>char.ToLower(c)).GroupBy(x => x).OrderByDescending(g=>g.Count()).Where(g=>g.Count() > 2).Select(c=>new { dc = c.Key,pl = c.Count()});
foreach (var c in chars)
{
    Console.WriteLine(c);
}
```

# 3. 控制反转(IoC)和依赖注入(DI)

## 引言

控制反转(IoC)实现方法：

1. （隐式）依赖注入：需要什么服务（类），直接在类里面写，然后系统在创建类的时候给服务（类）自动赋值。
2. （显式）服务定位器：需要什么服务（类）在给服务定位器要什么服务（类）

## 3.1 初始化使用

引用包：`Microsoft.Extensions.DependencyInjection`
首先需要创建一个容器：`ServiceCollection`
然后在容器中注册服务（类）
然后用`ServiceProvider`获取注册的对象
实例代码：

```C#
public interface ITestService
{
    public string Name { get; set; }
    public void SayHi();
}
public class TestServiceImpl : ITestService
{
    public string Name { get; set; }

    public void SayHi()
    {
        Console.WriteLine($"Hi , I'm {Name}");
    }
}
public class TestServiceImpl2 : ITestService
{
    public string Name { get; set; }

    public void SayHi()
    {
        Console.WriteLine($"你好 我是 {Name}");
    }
}
// 容器对象
ServiceCollection services = new ServiceCollection();
// 注册服务
services.AddTransient<TestServiceImpl>();
// 获取注册服务需要用到的工具
using(ServiceProvider serviceProvider = services.BuildServiceProvider())
{
	// 获取注册的服务
    TestServiceImpl test = serviceProvider.GetService<TestServiceImpl>();
    test.Name = "zz";
    test.SayHi();
}
```

## 3.2 服务使用范围

服务范围分为三种：

1. 单例：整个容器使用同一个实例对象
2. 瞬态：每次获取的都是一个新的实例对象
3. 范围：在一个范围内获取的是同一个实例对象

```C#
ServiceCollection services = new ServiceCollection();
//services.AddSingleton<TestServiceImpl>();// 创建单例
services.AddTransient<TestServiceImpl>();// 创建瞬态
//services.AddScoped<TestServiceImpl>();// 创建范围
using (ServiceProvider sp = services.BuildServiceProvider())
{
    TestServiceImpl t1 = sp.GetService<TestServiceImpl>();
    TestServiceImpl t2 = sp.GetService<TestServiceImpl>();
    TestServiceImpl t3 = null;
	// 创建一个范围
    using (IServiceScope scope = sp.CreateScope())
    {
		// 在范围中使用Provider
        t1 = scope.ServiceProvider.GetService<TestServiceImpl>();
        t1.Name = "aa";
        t3 = scope.ServiceProvider.GetService<TestServiceImpl>();
        t3.Name = "dd";
    }
	// 创建一个新的范围
    using(IServiceScope scope = sp.CreateScope())
    {
        t2 = scope.ServiceProvider.GetService<TestServiceImpl>();
        t2.Name = "bb";
    }
    // 单例情况 t1=t2 && t1==t3
    Console.WriteLine(t1==t2 && t1==t3);
    // 瞬态情况 t1!=t2 && t1 != t3
    Console.WriteLine(t1!=t2 && t1 != t3);
    // 范围情况 t1!=t2 && t1 == t3
    Console.WriteLine(t1!=t2 && t1==t3);
    t1.SayHi();
    t2.SayHi();
    t3.SayHi();
}
```

## 3.3 注册方法和获取实例的方法

```C#
ServiceCollection services = new ServiceCollection();
// 注册类与实现类相同
services.AddTransient<TestServiceImpl>();
// 注册类与实现类不同
//services.AddTransient<ITestService,TestServiceImpl>();
// 注册的不同方式，与上面的注册方式结果一致
services.AddTransient(typeof(ITestService),typeof(TestServiceImpl));


// 相同的注册类有多个不同的实现类 
services.AddTransient(typeof(ITestService), typeof(TestServiceImpl2));

using (ServiceProvider sp = services.BuildServiceProvider())
{


    // 如果要获取的注册类不存在GetService则返回null
    TestServiceImpl2 te2 = sp.GetService<TestServiceImpl2>();
    Console.WriteLine(te2);

    // 如果要获取的注册类不存在GetRequiredService则提示错误
    TestServiceImpl2 te3 = sp.GetRequiredService<TestServiceImpl2>();
    Console.WriteLine(te3);


    // 使用注册类获取想要的类
    TestServiceImpl t1 = sp.GetService<TestServiceImpl>();
    // 使用注册类获取想要的类
    //ITestService t2 = sp.GetService<ITestService>();
    // 不使用泛型获取对象 需要手动转换类型 与上面结果一致
    ITestService t2 = (ITestService)sp.GetService(typeof(ITestService));
    t1.Name = "aa";
    t1.SayHi();
    t2.Name = "bb";
    t2.SayHi();

    // 注册多个不同的实现类，如果使用GetService则获取最后注册的实现类
    ITestService t3 = sp.GetService<ITestService>();
    t3.Name = "cc";
    t3.SayHi();

    // 获取多个不同的实现类用GetServices
    IEnumerable<ITestService> t4 = sp.GetServices<ITestService>(); 
    foreach (ITestService t in t4)
    {
        t.Name = "11";
        t.SayHi();
    }

}
```

## 3.4 依赖注入传染性

.net 依赖注入使用的是构造函数注入方式，并且具有传染性。
比如有一个控制器中使用了日志和存储两个类，而存储中使用了日志类和配置类，则都只需要在其构造函数中写需要的类，然后在容器中注册，就可以直接使用。

#### 日志类代码

```C#
// 日志接口
public interface ILog
{
    public void Log(string message);
}
// 实现了日志接口的日志类
public class LogImpl : ILog
{
    public void Log(string message)
    {
        Console.WriteLine($"日志：{message}");
    }
}
```

#### 配置类代码

```C#
// 配置接口
interface IConfig
{
    public string GetValue(string key);
}
// 配置类
class ConfigImpl : IConfig
{
    public string GetValue(string key)
    {
        return "值是："+ key;
    }
}
```

#### 存储类代码

```C#
// 存储接口
interface IStorage
{
    public void Save(string content,string name);
}
// 存储类
class StorageImpl : IStorage
{
    private readonly IConfig config;
    // 通过依赖注入IConfig
    public StorageImpl(IConfig c)
    {
        this.config = c;
    }
    public void Save(string content, string name)
    {
        string server = config.GetValue("server");
        Console.WriteLine($"向服务器{server}的文件名为{name}上传"); 

    }
}
```

#### 控制器类代码

```C#
// 控制器
class Controller
{
    private readonly ILog _log;
    private readonly IStorage _storage;
    // 通过依赖注入Ilog和IStorage
    public Controller(ILog log,IStorage storage)
    {
        this._log = log;
        this._storage = storage;
    }
    public void Test()
    {
        this._log.Log("开始上传");
        this._storage.Save("","1.txt");
        this._log.Log("上传完成");
    }
}
```

#### 调用代码

```C#
ServiceCollection services = new ServiceCollection();
// 注册控制器
services.AddScoped<Controller>();
// 通过日志接口注册日志类
services.AddScoped<ILog,LogImpl>();
// 通过云存储接口注册云存储类
services.AddScoped<IStorage,StorageImpl>();
// 通过配置接口注册接口类
services.AddScoped<IConfig,ConfigImpl>();
using (ServiceProvider sp = services.BuildServiceProvider())
{
    // 获取控制器
    Controller controller = sp.GetService<Controller>();
    // 使用控制器
    controller.Test();
}
```

## 3.5 基本原理

**实例化带参数类**

如果一个类，在初始化时需要带一个参数，则在注册时使用`AddScoped`、`AddTransient`、`AddSingleton`的回调函数。

```C#
services.AddScoped<IConfigService>(s=>new TxtConfigServer() { FileName = "mail.ini"});
```

**使用扩展方法注册**

在注册时需要使用`AddScoped`、`AddTransient`、`AddSingleton`这三个方法来注册，如果一个功能需要注册很多个服务，则对调用者来说是一件很麻烦的事情，其中有一个服务未注册则会导致失败。
这时候如果可以把这些服务封装成一个方法，调用者直接`.Add`，不需要关心都注册哪些服务，就会很方便。
这种行为可以用扩展方法来实现。

**首先创建一个静态类，将静态类的命名空间改为 `Microsoft.Extensions.DependencyInjection`，然后创建一个静态方法，扩展`ServiceCollection`类**

```C#
namespace Microsoft.Extensions.DependencyInjection
{
    public static class TxtConfigServerRegister
    {
		// 调用者需要传入 fileName参数
        public static void AddTxtConfig(this ServiceCollection services,string fileName)
        {
            services.AddScoped<IConfigService>(s=>new TxtConfigServer() { FileName = fileName });
        }
    }
}
```

**调用者直接`.AddTxtConfig`即可注册服务**

```C#
ServiceCollection services = new ServiceCollection();
services.AddTxtConfig("mail.ini");
```

# 4. 配置文件

.net 可以读取多种不同类型的配置文件，如：json、xml、ini等。
读取配置文件需要使用到的包：

1. `Microsoft.Extensions.Configuration` 读取配置文件主要类库
2. `Microsoft.Extensions.Configuration.Binder` 将配置文件转换为实体类的类库
3. `Microsoft.Extensions.Configuration.Json` 读取json就使用json的类库，读取其他类型的文件用其他的类库

## 4.1. 读取一个本地的json文件

**1. 在项目中创建一个config.json文件并将属性->复制到输出目录->如果较新则复制**

文件内容如下：

```json
{
  "name": "张三",
  "age": "18",
  "students": {
    "name": "张同学",
    "age": 22
  }
}
```

**2. 在项目中添加配置文件所对应的实体类**

> 此步骤可以省略，如果不需要将配置文件映射为实体类的话，则将此步骤省略

```C#
internal class Student
{
    public int age { get; set; }
    public string Name { get; set; }
}
internal class Teacher
{
    public string Name { get; set; }
    public int Age { get; set; }
    public Student Students { get; set; }
}
```

**3. 在Main函数中读取配置文件**

```C#
// 配置文件构造类
ConfigurationBuilder builder = new ConfigurationBuilder();
// 在类中添加本地的配置文件
builder.AddJsonFile("config.json",optional: true,reloadOnChange: true);
// 初始化配置文件
IConfigurationRoot config = builder.Build();
// 通过[字段名]直接使用，返回值是一个字符串
string name = config["name"];
// *推荐使用方式 通过GetSection方法使用，Value表示获取值
string age = config.GetSection("age").Value;
Console.WriteLine("age:" + age);
Console.WriteLine("name:" + name);
// 通过Get将配置文件映射为一个类
Teacher teacher = config.Get<Teacher>();
Console.WriteLine("teacher.age:"+teacher.Age);
Console.WriteLine("teacher.Name:" + teacher.Name);
Console.WriteLine("teacher.students.Name:" + teacher.Students.Name);
Console.WriteLine("teacher.students.age:" + teacher.Students.age);
// 映射配置文件中的某一个值为一个类
Student student = config.GetSection("students").Get<Student>();
Console.WriteLine("student.name:"+student.Name);
Console.WriteLine("student.age:"+student.age);
Console.ReadKey();
```

`builder.AddJsonFile("config.json",optional: true,reloadOnChange: true);`方法有三个参数分别为：

1. 要读取配置文件的地址
2. optional：文件不存在是否报错如果为true，则文件不存在不会提示错误，如果为false，则文件在Build()的时候会提示文件不存在。
3. reloadOnChange：是否使用热加载，就是如果配置文件修改，则不需要启动程序就能重新读取配置文件

## 4.2 DI 方式读取配置文件

需要引用包：
`Microsoft.Extensions.Configuration` 配置文件类库
`Microsoft.Extensions.Configuration.Binder` 将配置文件转换成实体类的类库
`Microsoft.Extensions.Configuration.Json` 读取Json文件的类库
`Microsoft.Extensions.DependencyInjection` DI类库
`Microsoft.Extensions.Options` 热加载类库

**1. 先创建一个配置文件config.json，并将属性->复制到输出目录->如果较新则复制**

config.json内容如下：

```json
{
  "name": "张三",
  "age": "18",
  "students": {
    "name": "张同学",
    "age": 22
  }
}
```

**2. 创建配置文件对象的实体类：**

```C#
internal class Student
{
    public int age { get; set; }
    public string Name { get; set; }
}
internal class Teacher
{
    public string Name { get; set; }
    public int Age { get; set; }
    public Student Students { get; set; }
}
```

**3. 创建使用到配置文件的类**

```C#
internal class Test
{
    private readonly IOptionsSnapshot<Teacher> _optionsSnapshot;
    //private readonly IOptionsMonitor<Teacher> _optionsMonitor;
    public Test(IOptionsSnapshot<Teacher> optionsSnapshot)
    //public Test(IOptionsMonitor<Teacher> optionsMonitor)
    {
        this._optionsSnapshot = optionsSnapshot;
    }
    public void Run()
    {
        //Teacher teacher = this._optionsMonitor.CurrentValue;
        Teacher teacher = this._optionsSnapshot.Value;
        Console.WriteLine(teacher.Name);
        Console.WriteLine(teacher.Age);
    }
}
```

`IOptionsSnapshot`：在一个范围内，不会重新加载配置文件的内容，但出了范围后如果配置文件内容修改了，则重新加载。
`IOptionsMonitor`：配置文件的内容只会在启动时候加载

**4. 在Main函数中注册读取配置文件的服务**

```C#
static void Main(string[] args)
{
    // 实例化DI
    ServiceCollection services = new ServiceCollection();
    // 配置文件构造类
    ConfigurationBuilder builder = new ConfigurationBuilder();
    // 在类中添加本地的配置文件
    builder.AddJsonFile("config.json", false, true);
    // 初始化配置文件
    IConfigurationRoot config = builder.Build();
    // 在DI中注册配置文件的服务
    services.AddOptions().Configure<Teacher>(e=>config.Bind(e));
    services.AddScoped<Test>();
    using(ServiceProvider sp = services.BuildServiceProvider())
    {
        while (true)
        {
			// 创建一个范围
            using(IServiceScope scope = sp.CreateScope())
            {
                Test test = scope.ServiceProvider.GetRequiredService<Test>();
                test.Run();
                Console.ReadKey();
                test.Run();
                Console.ReadKey();
            }
        }

    }
    Console.ReadKey();
}
```

## 4.3 读取 web.config 配置

**以下代码的源代码仓库：https://gitee.com/shllong/.net-Read-webConfig/tree/master**

引用包：
`Microsoft.Extensions.Configuration` 配置类库
`Microsoft.Extensions.Configuration.Binder` 将配置转换为实体类的类库
`Microsoft.Extensions.Configuration.FileExtensions` 需要重写的类

**1. 创建一个web.config文件，并修改属性->复制到输出目录->如果较新则复制**

```xml
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
	<connectionStrings>
		<add name="conn1" connectionString="service=.;database=myschool;uid=sa;pwd=sa;" providerName="sql server"/>
		<add name="conn2" connectionString="service=127.0.0.1;database=myschool;uid=sa;pwd=sa;" providerName="mysql"/>
	</connectionStrings>
	<appSettings>
		<add key="name" value="张三"/>
		<add key="age" value="22"/>
		<add key="students:name" value="张同学"/>
		<add key="students.age" value="11"/>
		<add key="students:scores:0" value="100"/>
		<add key="students:scores:1" value="88"/>
	</appSettings>
</configuration>
```

**2. 创建配置文件的实体类**

配置文件读取到后转换为实体类

```C#
internal class Student
{
    public string Name { get; set; }
    public int Age { get; set; }
    public int[] Scores { get; set; }
}
internal class Teacher
{
    public string Name { get; set; }
    public int Age { get; set; }
    public Student Students { get; set; }
}
internal class ConnStr
{
    public string Name { get; set; }
    public string ConnectionString { get; set; }
    public string ProviderName { get; set; }
}
internal class Config
{
    public List<ConnStr> ConnStrs { get; set; }
    public Teacher teacher { get; set; }
	// 测试时候使用输出
    public override string ToString()
    {
        string connStr = "";
        foreach (ConnStr con in this.ConnStrs)
        {
            connStr += $"连接字符串名称：{con.Name} 连接字符串：{con.ConnectionString} 使用的数据库：{con.ProviderName};\n";
        }
        return $"连接字符串：{connStr}老师名称：{teacher.Name} 老师年龄：{teacher.Age} \n" +
            $"学生名称：{teacher.Students.Name} 学生年龄：{teacher.Students.Age} \n" +
            $"学生成绩：{string.Join(",", teacher.Students.Scores)}";
    }
}
```

**3. 创建 `FxConfigProvider` 类继承自 `FileConfigurationProvider`**

```C#
internal class FxConfigProvider : FileConfigurationProvider
{
    public FxConfigProvider(FileConfigurationSource source) : base(source)
    {
    }

    public override void Load(Stream stream)
    {
        // 创建一个不区分大小写的哈希表
        Dictionary<string,string> dic = new Dictionary<string,string>(StringComparer.OrdinalIgnoreCase);
        // 创建一个读取xml文档的工具类
        XmlDocument xmlDocument = new XmlDocument();
        // 初始化
        xmlDocument.Load(stream);
        // 处理连接字符串数据
        XmlNodeList connStrs = xmlDocument.SelectNodes("/configuration/connectionStrings/add");
        int i = 0;
        foreach(XmlNode node in connStrs.Cast<XmlNode>())
        {
            string name = node.Attributes["name"].Value;
            string connectionString = node.Attributes["connectionString"].Value;
            var providerName = node.Attributes["providerName"];
            if(providerName != null)
            {
                dic["ConnStrs:" + i + ":providerName"] = providerName.Value;
            }
			// 将数据进行扁平化处理
            dic["ConnStrs:" + i + ":ConnectionString"] = connectionString;
            dic["ConnStrs:" + i + ":name"] = name;
            i++;
        }
        // 处理appSettings中的数据
        connStrs = xmlDocument.SelectNodes("/configuration/appSettings/add");
        foreach (XmlNode node in connStrs.Cast<XmlNode>())
        {
            string key = node.Attributes["key"].Value;
            key = key.Replace(".",":");
            string value = node.Attributes["value"].Value;
            dic["teacher:" + key] = value;
        }
        // 将处理好的哈希表数据放到FileConfigurationProvider的Data数据中
        this.Data = dic;

    }
}
```

数据扁平化处理：

1. Student.Name = Student:Name
2. Student.Scores[0] = Student:Scores:0
3. Student.Scores[1] = Student:Scores:1

**4. 创建 `FxConfigSource` 类继承自 `FileConfigurationSource`**

这个类主要用来处理参数

```C#
internal class FxConfigSource : FileConfigurationSource
{
    public override IConfigurationProvider Build(IConfigurationBuilder builder)
    {
        EnsureDefaults(builder);
        return new FxConfigProvider(this);
    }
}
```

**5. 在Main函数中使用**

```C#
static void Main(string[] args)
{
    // 创建读取文件的工具类
    ConfigurationBuilder builder = new ConfigurationBuilder();
    // 将web.config文件添加到工具类中
    builder.Add(new FxConfigSource() { Path = "web.config"});
    // 初始化
    IConfigurationRoot root =  builder.Build();
    // 将配置文件映射为实体类
    Config config = root.Get<Config>();
    // 输出实体类数据
    Console.WriteLine(config.ToString());
    Console.ReadKey();
}
```

# 5. 日志系统

项目名称：`SystemLog`

## 5.1 基本使用

引用包：

`Microsoft.Extensions.Logging` 日志系统包

可选 `Microsoft.Extensions.Logging.Console` 将日志输出到控制台的包 

可选 `Microsoft.Extensions.Logging.EventLog` 将日志输出到 windows 下 `事件查看器` 中

**使用类 **

``` C#
public class Test1
{
    // 使用以来注入的方式获取日志类
    private readonly ILogger<Test1> _logger;
    public Test1(ILogger<Test1> logger)
    {
        this._logger = logger;
    }
    public void MM()
    {
        // 写入日志，日志等级由高到低
        this._logger.LogCritical("这是最高等级的提示Critical");
        this._logger.LogError("这是一个错误");
        this._logger.LogWarning("这是一个Warning提示");
        this._logger.LogInformation("这是一个info提示");
        this._logger.LogDebug("这是一个DeBug提示");
        this._logger.LogTrace("这是一个Trace提示");
        // 制造一个错误
        try
        {
            File.OpenRead("A:\a.txt");
            this._logger.LogInformation("这是成功了的提示");
        }
        catch(Exception ex) 
        {
            // 写入错误信息，包含系统的错误提示
            this._logger.LogError(ex,"这是错误之后的提示");
        }

    }
}
```

**Main方法**

``` C#
static void Main(string[] args)
{
    // 依赖注入容器
    ServiceCollection services = new ServiceCollection();
    // 注入日志系统
    services.AddLogging(builder =>
    {
        // 写入到控制台
        builder.AddConsole();
        // 设置最低写入等级为Trace，不设置的话，默认等级为 Warning，比 Warning 等级低的日志都不会写入
        builder.SetMinimumLevel(LogLevel.Trace);
        // 写入到 事件查看器
        builder.AddEventLog();
    });
    // 注入使用类
    services.AddScoped<Test1>();
    // 获取注册服务需要用到的工具
    using (var sp = services.BuildServiceProvider())
    {
        // 获取使用类的实例
        Test1 test =  sp.GetService<Test1>();
        // 调用使用方法
        test.MM();
    }
}
```

#### 非依赖注入方式使用

``` C#
private readonly ILoggerFactory _loggerFactory = LoggerFactory.Create(b => b.AddConsole());

optionsBuilder.UseLoggerFactory(this._loggerFactory);
```



## 5.2 NLog 使用

引用包：`NuGet\Install-Package NLog.Extensions.Logging -Version 5.3.8`

NLog官网：[NLog (nlog-project.org)](https://nlog-project.org/)

**在项目根目录下添加`nlog.config`文件并将文件属性->复制到输出目录->始终复制**

``` xml
<?xml version="1.0" encoding="utf-8" ?>

<!-- internalLogFile：nlong的日志 -->
<nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      autoReload="true"
      internalLogLevel="Info"
	  
      internalLogFile="temp\internal-nlog-AspNetCore.txt">

	<!-- enable asp.net core layout renderers -->
	<extensions>
		<add assembly="NLog.Web.AspNetCore"/>
	</extensions>

	<!-- 要写入的目标 -->
	<targets>
		<!-- 写入类型为文件写入 fileName是写入的文件地址 layout是写入的内容 archiveAboveSize:单个文件最大字节 maxArchiveFiles：同时存在日志文件数 -->
		<target xsi:type="File" name="allfile" fileName="temp\nlog-AspNetCore-all-${shortdate}.log" archiveAboveSize="10000" maxArchiveFiles="3"
				layout="${longdate}|${event-properties:item=EventId:whenEmpty=0}|${level:uppercase=true}|${logger}|${message} ${exception:format=tostring}" />

		<!-- File Target for own log messages with extra web details using some ASP.NET core renderers -->
		<target xsi:type="File" name="ownFile-web" fileName="temp\nlog-AspNetCore-own-${shortdate}.log"
				layout="${longdate}|${event-properties:item=EventId:whenEmpty=0}|${level:uppercase=true}|${logger}|${message} ${exception:format=tostring}|url: ${aspnet-request-url}|action: ${aspnet-mvc-action}" />

		<!--Console Target for hosting lifetime messages to improve Docker / Visual Studio startup detection -->
		<target xsi:type="Console" name="lifetimeConsole" layout="${MicrosoftConsoleLayout}" />
	</targets>

	<!-- 写入文件的规则 -->
	<rules>
		<!-- name默认为：命名空间+类名 minlevel:最小输出等级 writeTo输出到的目标，对应target的name属性 -->
		<logger name="*" minlevel="Trace" writeTo="allfile" />

		<!-- final=true：这条匹配到的话就不往下匹配了 -->
		<logger name="Microsoft.Hosting.Lifetime" minlevel="Info" writeTo="lifetimeConsole, ownFile-web" final="true" />

		<!-- maxlevel：最大的输出等级 -->
		<logger name="Microsoft.*" maxlevel="Info" final="true" />
		<logger name="System.Net.Http.*" maxlevel="Info" final="true" />
		
		<logger name="*" minlevel="Trace" writeTo="ownFile-web" />
	</rules>
</nlog>
```

**Program.cs 中添加如下代码：**

```C#
// 注入日志系统
services.AddLogging(builder =>
{
    ...
    builder.AddNLog();
});
```

NLog输出逻辑：Logging将日志输出给NLog然后NLog根据不同的rules（条件）将日志输出到不同的Target（目标文件）中。

![image-20240113213949554](学习笔记.assets\image-20240113213949554.png)

## 5.3 Serilog 使用

**优势：**输出结构化日志，比如json格式比较方便，集群部署项目时候使用Serilog+“集中式日志服务”

**引用包：`Serilog.AspNetCore`**

**Program.cs 中添加如下代码：**

``` C#
services.AddLogging(builder =>
{
    // Serilog
    Log.Logger = new LoggerConfiguration()
        .MinimumLevel.Debug()
        .Enrich.FromLogContext()
        // 以JSON格式输出
        .WriteTo.Console(new JsonFormatter())
        .CreateLogger();
    builder.AddSerilog();
});
```

**结构化输出对象：**

``` c#
User user = new User();
user.id = 1;
user.name = "Test";
this._logger.LogDebug("这是一个人：{@u}", user);
```



# 6. EF 使用

EFCore分为三类：

+ `DB First`：先有数据库，最新版本不支持，当时有类似的功能存在
+ `Model First`：先有实体类，最新版本不支持
+ `Code First`：先有代码

**不同数据库的不同支持**

![image-20240720075057012](学习笔记.assets\image-20240720075057012.png)

> 这是EFCore底层运行的机制
>
> AST：将C#语句翻译成抽象语法树

先调用EF Core核心，然后再使用AST生成SQL结构树，然后根据要使用的数据库，调用不同数据库的Provider，如果要使用的数据库没有Provider，则不可以使用EFCore。只能使用ADO .NET Core。（一般国产数据库如果没有Provider，则可以尝试使用Mysql的Provider）

## 6.1 Code Frist

引用包：`Microsoft.EntityFrameworkCore.SqlServer`

### 基本使用
**1. 创建实体类**

创建实体类：`Book.cs`

``` C#
public class Book
{
    public long Id { get; set; }
    public string Title { get; set; }
    public DateTime PubTime { get; set; }
    public double Price { get; set; }
}
```

**2. 创建配置类（可选）**

> 该类可以不创建，EF Core 有默认的配置

创建Book的配置类：`BookConfig.cs`，该类继承自`IEntityTypeConfiguration`

``` C#
/// <summary>
/// IEntityTypeConfiguration<Book> Book表示这个类是Book类的配置类
/// </summary>
public class BookConfig : IEntityTypeConfiguration<Book>
{
    public void Configure(EntityTypeBuilder<Book> builder)
    {
        // 设置在数据库中的表名
        builder.ToTable("T_Books");
    }
}
```

**3. 创建DbContent类**

创建DbContent类：`EFCoreLearnContent.cs`，该类继承自`DbContent`

``` C#
public class EFCoreLearnContent : DbContext
{
    // 指定这个DbContext中都包含那些实体类
    public DbSet<Book> Books { get; set; }
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        base.OnConfiguring(optionsBuilder);
        // 数据库连接字符串
        optionsBuilder.UseSqlServer("server=.;uid=sa;pwd=sa;database=EFCoreLearn;");
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
		// 从当前程序集加载所有的IEntityTypeConfigration
        modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);
    }
}
```

**4. 使用Migration工具在数据库生成或修改表**

在使用Migration工具之前需要引用包：`Microsoft.EntityFrameworkCore.Tools`

> 创建和修改数据库时都必须要做的操作

创建数据库修改记录，`name` 表示本次修改记录的名字，与变量的命名标准一致就可

> 如果要将不同的迁移脚本放到不同的文件夹底下，则使用`-OutputDir`参数。

``` C#
Add-Migration name
```

修改数据库

``` C#
Update-Database
```

**5.查询数据**

``` C#
using(EFCoreLearnContent db = new EFCoreLearnContent())
{
    var books = db.Books.Where(a=>a.Id > 10); // 查询id大于10的数据
    foreach(var a in books)
    {
        Console.WriteLine(a.Id);
    }
}
```

**6.只查询指定字段**

> 有时候数据库中表的字段太多，只想查询某几个字段，可以使用Select来实现

``` C#
using(EFDBContent db = new EFDBContent())
{
    var articles = db.articles.Where(a=>a.Id > 10).Select(a=>new { a.Id,a.Title}); // 在Select中使用匿名类型
    foreach(var a in articles)
    {
        Console.WriteLine(a.Id);
    }
}
// 或者
using(EFDBContent db = new EFDBContent())
{
    var articles = db.articles.Where(a=>a.Id > 10).Select(a=>new object[]{ a.Id,a.Title}); // 使用创建object数组来实现
    foreach(var a in articles)
    {
        Console.WriteLine(a[0]);
    }
}
```

### 在.Net Core WebApi中使用

**1. 定义实体类**、

``` C#
public class Book
{
    public long Id { get; set; }
    public string Title { get; set; }
    public DateTime PubTime { get; set; }
    public double Price { get; set; }
}
```

**2. 创建DbContext**

``` C#
public class MyDbContext : DbContext
{
    public MyDbContext(DbContextOptions<MyDbContext> options) : base(options) 
    {
        
    }
    public DbSet<Book> Books { get; set; }
   
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        // 从当前程序集加载所有的IEntityTypeConfigration
        modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);
    }
}
```

**3. 在`Program.cs`中注册**

``` C#
builder.Services.AddDbContext<MyDbContext>(x => x.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));
```

**4. 在`appsettings.json`中添加连接字符串**

``` Json
{
  ...
  "ConnectionStrings": {
    "DefaultConnection": "server=.;uid=sa;pwd=sa;database=demo1;"
  }
}

```

**5. 执行迁移添加数据库**

``` C#
Add-Migration
Update-Database
```



### 修改表字段、类型、长度

> 修改表字段名等操作直接在实体类上修改即可。
>
> 修改表字段的类型、长度等操作都需要使用表配置类，也就是继承自`IEntityTypeConfiguration`的类。

``` C#
public class Book
{
    ...
    // 类型可空
    public double? Price { get; set; }
    public long PersonId { get; set; }
}
```

``` C#
public class BookConfig : IEntityTypeConfiguration<Book>
{
    public void Configure(EntityTypeBuilder<Book> builder)
    {
        // 设置在数据库中的表名
        builder.ToTable("T_Books");
        // Title字段不为空
        builder.Property(x => x.Title).IsRequired();
        // Title字段长度为50
        builder.Property(b => b.Title).HasMaxLength(50);
        // 设置字段默认值
        builder.Property(b => b.PubTime).HasDefaultValueSql("getdate()");
        // 设置字段类型，并且字段不为空
        builder.Property(b => b.Price).HasColumnType("decimal(18, 2)").IsRequired();
    }
}
```

修改完代码后使用Migration工具修改数据库后，数据库的表才会发生改变。

### 主键

#### GUID

使用Guid作为主键的时候，将模型的类型设置为Guid，名称为Id，则生成的数据库类型为`uniqueidentifier`

``` C#
public class Rabbit
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public int Age { get; set; }
}
```

数据库表：

![image-20240719155648603](学习笔记.assets\image-20240719155648603.png)

#### HI/Lo 高低位

### 迁移

使用迁移脚本，可以对当前连接的数据库执行编号更高的迁移，这个操作叫做“向上迁移”（Up），也可以执行吧数据库回退到旧的迁移，这个操作叫“向下迁移”（Down）。除非有特殊需要，否则不要删除Migrations文件夹下的代码。数据库中会有个`__EFMigrationsHistory`表，记录了当前数据库曾经应用过的迁移脚本。

#### 将数据库回滚到某个版本

`update-Database XXX`

> 其中，XXX为Migration的版本名称

#### 删除某个迁移脚本

> 从最近一次生成的迁移文件开始删除

使用语句：`remove-migration`

#### 生成数据库SQL语句

使用语句：`script-migration`

会生成一个sql脚本，复制到sql server 中运行即可创建数据库

生成一个从D版本到F版本之间的sql语句：`script-migration D F`\

生成一个从D版本到最新版本之间的sql语句：`script-migration D`

## 6.2 DB First（反向工程）

**从数据库创建模型(DB First)**：`Scaffold-DbContext 'Data Source=.;Initial Catalog=DB;integrated security=True;' Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -Context DBContext`

上面的效果只是实现了类似于DB First的效果，`Scaffold-DbContext`是一个工具

`-OutputDir Models `： 指定生成的目录

`-Context DBContext`：指定Context名称

`-Force` ：当数据库发送改变时添加此参数覆盖生成实体类

### 6.3 查看EFCore 生成的SQL代码

#### 1. 使用SQL Server Profiler工具查看

> 只能在SQL Server 中查看。

在SQL Server 中的工具-SQL Server Profiler 打开。

#### 2. 使用.Net日志查看（标准日志）

``` C#
public class EFDBContent: DbContext
{
    private readonly ILoggerFactory _loggerFactory = LoggerFactory.Create(b => b.AddConsole()); // 生成一个控制台日志
    public DbSet<Rabbit> Rabbits { get; set; }
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        base.OnConfiguring(optionsBuilder); 
        optionsBuilder.UseLoggerFactory(this._loggerFactory); // 在控制台输出生成的SQL语句
        optionsBuilder.UseSqlServer("server=.;uid=sa;pwd=sa;database=LearnEFCore");
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);
    }
}
```

#### 3. 使用EFCore内置的简单日志查看（简单日志）

``` C#
public class EFDBContent: DbContext
{
    public DbSet<Rabbit> Rabbits { get; set; }
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        base.OnConfiguring(optionsBuilder);
        optionsBuilder.LogTo(msg => // 输出生成的SQL语句
        {
            if (!msg.Contains("CommandExecuting")) return; // 这行代码可以去掉，如果觉得输出的日志不够详细，可以去掉这行代码
            Console.WriteLine(msg);
        });
        optionsBuilder.UseSqlServer("server=.;uid=sa;pwd=sa;database=LearnEFCore");
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);
    }
}
```

#### 4. 单个语句查看SQL（只针对查询）

``` C#
IQueryable<Rabbit> rabbits = db.Rabbits.Where(b => b.Name.Contains("1"));
Console.WriteLine(rabbits.ToQueryString()); // 获取上面代码生成的SQL语句
```

> 需要引用`Microsoft.EntityFrameworkCore`
>
> `ToQueryString` 方法是`IQueryable`的扩展方法

## 6.3 连接不同数据库

### Mysql 数据库

使用包：`Pomelo.EntityFrameworkCore.MySql `

DBContext：

``` C#
public class EFDBContent: DbContext
{
    public DbSet<Rabbit> Rabbits { get; set; }
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        base.OnConfiguring(optionsBuilder);
        optionsBuilder.UseMySql("server=localhost;user=root;password=admin;database=demo5", new MySqlServerVersion(new Version(8, 0, 34)));
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);
    }
}
```

### Postgresql数据库

使用包`Npgsql.EntityFrameworkCore.PostgreSQL`

DBContext：

``` C#
public class EFDBContent: DbContext
{
    public DbSet<Rabbit> Rabbits { get; set; }
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        base.OnConfiguring(optionsBuilder);
        optionsBuilder.UseNpgsql("Host=127.0.0.1;Database=demo5;Username=postgres;Password=123456");
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);
    }
}
```

## 6.4 外键关系

### 一对多（HasOne(...).WithMany(...)）

文章类实体类配置：

``` C#
public class ArticleConfig : IEntityTypeConfiguration<Article>
{
    public void Configure(EntityTypeBuilder<Article> builder)
    {
        builder.ToTable("T_Article");
        builder.HasKey(a => a.Id);
        builder.Property(a=>a.Title).HasMaxLength(100).IsRequired();
        builder.Property(a=>a.Message).IsRequired();
    }
}
```

评论类实体类配置：

``` C#
public class CommentConfig : IEntityTypeConfiguration<Comment>
{
    public void Configure(EntityTypeBuilder<Comment> builder)
    {
        builder.ToTable("T_Comment");
        builder.HasKey(c => c.Id);
        builder.Property(c => c.Message).IsRequired();
        // c表示Comment（评论类）
        // a表示Article（文章类）
        // 当前文章中的Article属性指定一个Article类，在Article类中的comments属性可以表示多个Comment类
        builder.HasOne<Article>(c => c.Article).WithMany(a => a.comments);
    }
}
```

这样生成的数据库会自动创建一个一对多的关系，在T_Comment表中创建ArticleId字段，外键连接T_Article中的Id主键。

> **插入数据库数据**时会递归插入，当有被引用的数据时则自动插入

``` C#
// 插入代码
using(EFDBContent db = new EFDBContent())
{
    Article a1 = new Article();
    a1.Title = "这是个标题";
    a1.Message = "Test";

    Comment c1 = new Comment() { Message="这是抵押给" };
    Comment c2 = new Comment() { Message= "这是的萨芬" };
    a1.comments.Add(c1);
    a1.comments.Add(c2);

    db.articles.Add(a1);
    db.SaveChanges();
}
```

> 代码中并未将c1、c2插入到数据库，但是实际运行后，c1、c2的数据已经插入到数据库中，是因为efcore检测到了a1.comments中有c1和c2，则将c1、c2插入到数据库中。

**查询（连表查询）**

``` C#
Article article = db.articles.Single(a=>a.Id== 1);
Console.WriteLine(article.Title);
Console.WriteLine(article.Message);
foreach(Comment c in article.comments)
{
    Console.WriteLine(c.Message);
}
```

以上代码查出来的`comments`的数量为0，因为连表查询需要使用关键字`Include(a=>a.要连表查询的属性)`（ef 6.0 以后不需要Include也可以自动查询）

`Include` 方法在`Microsoft.EntityFrameworkCore`命名空间下

```C#
Article article = db.articles.Include(a=>a.comments).Single(a=>a.Id== 1);
Console.WriteLine(article.Title);
Console.WriteLine(article.Message);
foreach(Comment c in article.comments)
{
    Console.WriteLine(c.Message);
}
```

改成以上代码，就可以查出某个文章下的所有评论了。

同理，在评论区中查询文章也需要使用`Include`方法。

``` C#
Comment c = db.comments.Include(c=>c.Article).First(c=>c.Id==1);
Console.WriteLine(c.Message);
Console.WriteLine(c.Article.Message);
```

**额外的主键** 

> 当在评论区表只需要文章表的Id时，使用Include方法连表查询速度太慢，可以在评论表中添加一个新的字段，然后再评论表的配置类中，设置外键，再进行查询的时候，就可以直接查询文章表的Id了。

评论实体类：

``` c#
public class Comment
{
    public int Id { get; set; }
    public string Message { get; set; }
    public int ArticleId { get; set; } // 添加的外键字段
    public Article Article { get; set; }
}
```

评论配置类：

``` C#
public void Configure(EntityTypeBuilder<Comment> builder)
{
    builder.ToTable("T_Comment");
    builder.HasKey(c => c.Id);
    builder.Property(c => c.Message).IsRequired();
    builder.HasOne<Article>(c => c.Article).WithMany(a => a.comments).HasForeignKey(c=>c.ArticleId);
}
```

> `HasForeignKey`指定外键字段

使用：

``` C#
Comment c = db.comments.First();
Console.WriteLine(c.Id + "," + c.ArticleId);
```

### 导航属性

``` C#
public class Comment
{
    public int Id { get; set; }
    public string Message { get; set; }
    public int ArticleId { get; set; }
    public Article Article { get; set; } // 导航属性
}
```

> 外键关系在实体类中名为导航属性。

**单向导航属性**

> 有一个用户表，有报销单、订单、购物车等各种表都引用了用户表，但是只需要在报销单等表中添加用户属性，不需要在用户表中添加报销单的集合。

报销单配置类：

``` C#
public class OrderConfig : IEntityTypeConfiguration<Order>
{
    public void Configure(EntityTypeBuilder<Order> builder)
    {
        builder.ToTable("T_Orders");
        builder.HasOne<User>(o => o.FUser).WithMany();
        builder.HasOne<User>(o=>o.NUser).WithMany();
    }
}
```

> 如果在创建数据库的时候提示这个错误：`将 FOREIGN KEY 约束 'FK_T_Orders_T_Users_NUserId' 引入表 'T_Orders' 可能会导致循环或多重级联路径。请指定 ON DELETE NO ACTION 或 ON UPDATE NO ACTION，或修改其他 FOREIGN KEY 约束。`
>
> 则将NUser设置为可空

**双向导航属性**

> 有一个文章表，有一个评论表，评论表中有个属性对应一篇文章，文章表中有一个集合对应评论表

评论表配置类：

``` C#
public class CommentConfig : IEntityTypeConfiguration<Comment>
{
    public void Configure(EntityTypeBuilder<Comment> builder)
    {
        builder.ToTable("T_Comment");
        builder.HasKey(c => c.Id);
        builder.Property(c => c.Message).IsRequired();
        builder.HasOne<Article>(c => c.Article).WithMany(a => a.comments).HasForeignKey(c=>c.ArticleId);
    }
}
```

或者在文章表中配置：

``` C#
public class ArticleConfig : IEntityTypeConfiguration<Article>
{
    public void Configure(EntityTypeBuilder<Article> builder)
    {
        builder.ToTable("T_Article");
        builder.HasKey(a => a.Id);
        builder.Property(a=>a.Title).HasMaxLength(100).IsRequired();
        builder.Property(a=>a.Message).IsRequired();
        builder.HasMany<Comment>(a => a.comments).WithOne(c => c.Article).HasForeignKey(c=>c.ArticleId);
    }
}
```

> 双向导航在任意双方配置都可以，单向导航只能在一个里面配置。

**自引用结构**

> 当写一个族谱的时候，只需要一张表，但是表中有一个外键连接本表的Id时，需要使用到自引用结构

自引用结构实体类：

``` C#
public class User
{
    public int Id { get; set; }
    public string Name { get; set; }
    public User? Parent { get; set; } // 可空，表示此人如果是根节点的话，则没有父节点
    public List<User> Childs { get; set; } = new List<User>();
}
```

配置类：

``` C#
public class UserConfig : IEntityTypeConfiguration<User>
{
    public void Configure(EntityTypeBuilder<User> builder)
    {
        builder.ToTable("T_Users");
        builder.HasKey(x => x.Id);
        builder.HasOne(x=>x.Parent).WithMany(x=>x.Childs).OnDelete(DeleteBehavior.Restrict);
    }
}
```

**DeleteBehavior**是一个枚举类型，有不同的选项

| **DeleteBehavior** | 对数据库架构的影响                                           |
| ------------------ | ------------------------------------------------------------ |
| Cascade            | ON DELETE CASCADE                                            |
| NoAction           | 数据库默认值                                                 |
| SetNull            | ON DELETE SET NULL                                           |
| ClientSetNull      | 数据库默认值                                                 |
| ClientCascade      | 数据库默认值                                                 |
| ClientNoAction     | 数据库默认值                                                 |
| Restrict           | 删除外键指向的数据，则外键改为空，如果改属性不能为空则抛出异常 |

关系数据库中 `ON DELETE NO ACTION`（数据库默认值）和 `ON DELETE RESTRICT` 的行为通常相同或非常相似。 尽管 `NO ACTION` 可能意味着什么，但这两个选项都会导致强制执行引用约束。 区别是当有一个时，是影响数据库何时检查约束。 请查看数据库文档，了解数据库系统上 `ON DELETE NO ACTION` 和 `ON DELETE RESTRICT` 之间的具体区别。

SQL Server 不支持 `ON DELETE RESTRICT`，因此改为使用 `ON DELETE NO ACTION`。

导致数据库级联行为的唯一值是 `Cascade` 和 `SetNull`。 所有其他值会将数据库配置为不级联任何更改。

### 一对一（HasOne(...).WithOne(...)）

> 一个员工配备一台电脑，一个电脑属于一个员工

员工实体类：

``` C#
public class User
{
    public int Id { get; set; }
    public string UserName { get; set;}
    public Computer Computer { get; set; }
}
```

电脑实体类：

``` C#
public class Computer
{
    public int Id { get; set; }
    public string Name { get; set; }
    public User User { get; set; }
    public int UserId { get; set; }
}
```

电脑类可不用配置。

员工类配置：

``` C#
public class UserConfig : IEntityTypeConfiguration<User>
{
    public void Configure(EntityTypeBuilder<User> builder)
    {
        builder.ToTable("T_Users");
        builder.HasOne<Computer>(u => u.Computer).WithOne(c => c.User).HasForeignKey<Computer>(c => c.UserId);
    }
}
```

> 一对一关系的时候需要在其中一个里面设置一个外键，然后在另一个的配置类中写外键约束，指向设置的外键。

### 多对多（HasMany(...).WithMany(...)）

> 一个老师有多个学生，一个学生有多个老师

学生实体类：

``` C#
public class Student
{
    public int Id { get; set; }
    public string Name { get; set; }
    public List<Teacher> Teachers { get; set; } = new List<Teacher>();
}
```

老师实体类：

``` C#
public class Teacher
{
    public int Id { get; set; }
    public string Name { get; set; }
    public List<Student> Students { get; set; } = new List<Student>();
}
```

老师实体配置类：

``` C3
public class TeacherConfig : IEntityTypeConfiguration<Teacher>
{
    public void Configure(EntityTypeBuilder<Teacher> builder)
    {
        builder.ToTable("T_Teacher");
        builder.HasMany<Student>(t => t.Students).WithMany(s => s.Teachers).UsingEntity("T_Teacher_Student");
    }
}
```

> 关系可以配置在学生实体类中，也可以配置到老师实体类中。

## 6.5 查询(初级使用)

**查询评论中包括Steam的文章，输出文章标题**

``` C#
// 初始化数据
Article a1 = new Article() { Title = "微软发布....",Message="微软发布。。。"};
Article a2 = new Article() { Title = "Steam游戏100", Message = "Steam游戏榜单" };
Article a3 = new Article() { Title = "黑神话悟空游戏发售", Message = "黑神话悟空" };
Comment c1 = new Comment() { Message="微软牛逼", Article = a1 };
Comment c2 = new Comment() { Message="Steam牛逼", Article = a2 };
Comment c3 = new Comment() { Message="Steam卖328", Article = a3 };
Comment c4 = new Comment() { Message="国产崛起", Article = a3 };
Comment c5 = new Comment() { Message=".net 崛起", Article = a1 };
Comment c6 = new Comment() { Message="Steam 无删减版本", Article = a3 };
db.articles.Add(a1);
db.articles.Add(a2);
db.articles.Add(a3);
db.comments.Add(c1);
db.comments.Add(c2);
db.comments.Add(c3);
db.comments.Add(c4);
db.comments.Add(c5);
db.comments.Add(c6);
db.SaveChanges();
// 查询语句 查询文章中的所有评论，每个评论中至少有一个包含Steam的
var item = db.articles.Where(a=>a.comments.Any(c=>c.Message.Contains("Steam")));
foreach(var article in item)
{
    Console.WriteLine(article.Title);
}
// 查询语句 查询所有评论中包含Steam的，然后用投影获取文章，再去重复
var item = db.comments.Where(c => c.Message.Contains("Steam")).Select(c => c.Article).Distinct();
foreach(var article in item)
{
    Console.WriteLine(article.Title);
}
```

## 6.6 IEnumerable 和 IQueryable 区别

> IEnumerable：在内存中筛选数据（客户端评估）
>
> IQueryable：将条件转换为SQL语句，在数据库中筛选数据（服务器端评估）

客户端评估

``` C#
IEnumerable<Article> item= db.articles;
IEnumerable<Article> articles = item.Where(a => a.comments.Any(c => c.Message.Contains("Steam")));
foreach (var article in articles)
{
    Console.WriteLine(article.Title);
}
//生成的SQL语句
SELECT [t].[Id], [t].[Message], [t].[Title]
      FROM [T_Article] AS [t]
```

服务器端评估

``` C#
IQueryable<Article> item= db.articles;
IEnumerable<Article> articles = item.Where(a => a.comments.Any(c => c.Message.Contains("Steam")));
foreach (var article in item)
{
    Console.WriteLine(article.Title);
}
// 生成的SQL语句 
SELECT [t].[Id], [t].[Message], [t].[Title]
      FROM [T_Article] AS [t]
      WHERE EXISTS (
          SELECT 1
          FROM [T_Comment] AS [t0]
          WHERE ([t].[Id] = [t0].[ArticleId]) AND ([t0].[Message] LIKE N'%Steam%'))
```

### 使用场景

> 大部分场景下都使用服务器端评估
>
> 在小部分场景下可以使用客户端评估，比如在当条件复杂无法生成SQL语句的时候，可以使用客户端评估

``` C#
static bool IsOk(string s)
{
    if (s.StartsWith("a"))
    {
        return s.Length > 5;
    }
    else
    {
        return s.Length < 5;
    }
}
// 当使用方法时，无法转换为SQL语句，此时可以使用客户端评估
var item = ((IEnumerable<Comment>)db.comments).Where(c => IsOk(c.Message));
foreach(var comment in item)
{
    Console.WriteLine(comment.Message);
}
```

### 一次性加载

> IQueryable 底层使用的是DataReader实现，每次遍历IQueryable集合的时候都需要一直与数据库保持连接，如果数据库连接断开，则遍历会提示错误

**使用场景1** ：遍历IQueryable并且 进行数据处理的过程很耗时

``` C#
List<Article> articles = db.articles.ToList();
foreach(Article article in articles)
{
    Console.WriteLine(article.Title);
    Thread.Sleep(10);
}
```

**使用场景2** ：如果方法需要返回查询结果，并且在方法里销毁DbContext的话，是不能返回IQueryable的。必须一次性加载返回。

``` C#
static List<Article> GetArticles()
{
    using(var  db = new EFDBContent())
    {
        return db.articles.ToList();
    }
}

foreach(var article in GetArticles())
{
    Console.WriteLine(article.Title);
}
```

**使用场景3 ** ：多个IQueryable的遍历嵌套。很多数据库的ADO.NET Core Provider 是不支持多个DataReader同时执行的（SQL Server 在连接字符串中添加`MultipleActiveResultSets=true`则可以支持多个DataReader同时执行）。所以需要一次性加载

``` C#
foreach(var article in db.articles.ToList())
{
    Console.WriteLine(article.Title);
    foreach (var item in db.comments) {
        Console.WriteLine(item.Message);
    }
}
```

### 异步遍历

> 在增删改的时候推荐使用异步，但是一般的查询没必要使用异步，除非遇到性能**瓶颈**

**第一种方法**：使用`ToListAsyn()`方法

``` C#
static async Task Main(string[] args){
    foreach(var a in await db.articles.ToListAsync())
    {
        await Console.Out.WriteLineAsync(a.Title);
    }
}
```

**第二种方法**：使用`await foreach(...AsAsyncEnumerable()) `方法

``` C#
static async Task Main(string[] args){
    await foreach(var a in db.articles.AsAsyncEnumerable())
    {
        await Console.Out.WriteLineAsync(a.Title);
    }
}z
```

## 6.7 延迟执行

> IQueryable只是代表一个“可以放到数据库服务器去执行的查询”，并没有立即执行，只是“可以被执行”而已。
>
> 对于IQueryable接口调用非终结方法的时候不会执行查询，而调用终结方法的时候则立即执行查询

> 终结方法：遍历、ToArray()、ToList()、Min()、Max()、Count()等

> 非终结方法：GroupBy()、OrderBy()、Include()、Skip()、Take()等

> 简单判断：一个方法返回值类型如果是IQueryable类型，那么这个方法一般就是非终结方法，否则就是终结方法

总结，延迟执行可以用来做多条件判断，相当于拼接SQL查询语句

``` C#
static void Search(string data,bool isAll,bool isOrder,double price)
{
    using(var db = new EFDBContent())
    {
        IQueryable<Article> articles = db.articles.Where(a=>a.Price >= price);
        if(isAll)
        {
            articles.Where(a => a.Message.Contains(data) || a.Title.Contains(data));
        }
        else
        {
            articles.Where(a => a.Message.Contains(data));
        }
        if(isOrder)
        {
            articles.OrderByDescending(a => a.Price);
        }
        foreach(var article in articles)
        {
            Console.WriteLine(articles);
        }
    }
}
```

### 条件复用

> IQueryable 条件是可以被复用的

``` C#
IQueryable<Article> articles = db.articles.Where(a=>a.Id > 0); // 这句话不被执行，所以不单独生成SQL
Console.WriteLine(articles.Count());
// 生成的SQL
SELECT COUNT(*)
      FROM [T_Article] AS [t]
      WHERE [t].[Id] > 0
Console.WriteLine(articles.Max(a=>a.Price));
// 生成的SQL
SELECT MAX([t].[Price])
      FROM [T_Article] AS [t]
      WHERE [t].[Id] > 0
IQueryable<Article> articles1 = articles.Where(a => a.Title.Contains("微软")); // 这句话不被执行，所以不单独生成SQL
articles1.ToList();
// 生成的SQL
SELECT [t].[Id], [t].[Message], [t].[Price], [t].[Title]
      FROM [T_Article] AS [t]
      WHERE ([t].[Id] > 0) AND ([t].[Title] LIKE N'%微软%')
```

## 6.8 查询（高级使用）

### 分页查询

``` C#
/// <summary>
/// 分页查询
/// </summary>
/// <param name="index">页码（从1开始）</param>
/// <param name="pageSize">一页包括几行</param>
static void PageSearch(int index, int pageSize)
{
    using (var db = new EFDBContent())
    {
        var articles = db.articles;
        var item = articles.Skip((index - 1) * pageSize).Take(pageSize);
        foreach (var article in item)
        {
            Console.WriteLine(article.Title);
        }
        long count = articles.Count();
        Console.WriteLine("总条数：" + count);
        long pageCount = (long)Math.Ceiling(count*1.0 / pageSize);
        Console.WriteLine("总页数：" +  pageCount);
    }
}
```

## 6.9 在EF 中使用SQL语句

### 非查询语句

``` C#
string msg = "你好";
FormattableString sql = $"insert into T_Article(Title,Message,Price) select Title,{msg},Price from T_Article where id < 10";
await db.Database.ExecuteSqlInterpolatedAsync(sql);
```

> 必须使用带$的字符串，因为$会将字符串转换为`FormattableString`类型
>
> `FormattableString`类型会自动将带入的变量转换为执行sql时的参数，能防止sql注入的问题

也可以使用另一个方法，但是不建议使用因为要自己写参数预防sql注入。

``` C#
string msg = "你好";
string sql = "insert into T_Article(Title,Message,Price) select Title,'" + msg + "',Price from T_Article where id < 10";
await db.Database.ExecuteSqlRawAsync(sql);
```

``` C#
// ExecuteSqlRaw 参数列表
public static int ExecuteSqlRaw (this Microsoft.EntityFrameworkCore.Infrastructure.DatabaseFacade databaseFacade, string sql, params object[] parameters);
```

### 实体查询

> 使用`DbSet.FromSqlInterpolated(FormattableString sql)`方法，方法的返回值是IQueryable类型

``` C#
IQueryable<Article> articles = db.articles.FromSqlInterpolated($"select * from T_Article order by newid()");
foreach( Article article in articles )
{
    await Console.Out.WriteLineAsync(article.Title);
}
```

实体查询具有局限性：

+ SQL 查询必须返回实体类型对应数据库表的所有列
+ 结果集中的列名必须与属性映射到的列名称匹配
+ 只能单表查询，不能使用Join语句进行相关联查询。但是可以在查询后面使用`Include()`来进行关联数据的获取

**SQL语句+IQueryable结合**

``` C#
IQueryable<Article> articles = db.articles.FromSqlInterpolated($"select * from T_Article");
foreach (Article article in articles.OrderBy(a=>Guid.NewGuid()).Skip(1).Take(2))
{
    await Console.Out.WriteLineAsync(article.Title);
    foreach(Comment comment in article.comments)
    {
        await Console.Out.WriteLineAsync("\t" + comment.Message);
    }
}

// 生成的SQL语句
SELECT [一].[Id], [一].[Message], [一].[Price], [一].[Title]
      FROM (
          select * from T_Article
      ) AS [一]
      ORDER BY NEWID()
      OFFSET @__p_1 ROWS FETCH NEXT @__p_2 ROWS ONLY
```

> 如果结合使用的话，编译器会自动将sql语句变成一个子查询。

### 任意SQL查询

> 在EF Core 中可以获取ADO.NET的Connection对象，然后执行原生的ADO.NET代码。

``` C#
DbConnection conn = db.Database.GetDbConnection();
if(conn.State != System.Data.ConnectionState.Open)
    conn.Open();
using(var cmd = conn.CreateCommand())
{
    cmd.CommandText = "select Price,count(*) from T_Article group by Price";
    using(var reader = await cmd.ExecuteReaderAsync())
    {
        while (await reader.ReadAsync())
        {
            await Console.Out.WriteLineAsync($"{reader.GetDouble(0)}:{reader.GetInt32(1)}");
        }
    }

}
```

**扩展DbContext类，添加`ExecuteSqlQuery`和`ExecuteNonQuery`方法**

``` C#
public static class EFCoreExecuteSql
{
    /// <summary>
    /// 查询方法
    /// </summary>
    /// <param name="sql">要执行的SQL语句</param>
    /// <param name="cmdType">SQL语句的类型，默认为文本类型</param>
    /// <param name="parameters">参数</param>
    /// <returns>查询的到数据</returns>
    public static IEnumerable<dynamic> ExecuteSqlQuery(this DbContext dbContext, string sql, CommandType cmdType = CommandType.Text, params DbParameter[] parameters)
    {
        DbConnection conn = dbContext.Database.GetDbConnection();
        if (conn.State != ConnectionState.Open)
        {
            conn.Open(); //打开连接
        }
        using (var cmd = conn.CreateCommand())
        {
            cmd.CommandText = sql;
            cmd.CommandType = cmdType;
            //添加输入参数
            cmd.Parameters.AddRange(parameters);

            //执行命令，读取器读取数据
            using (var dataReader = cmd.ExecuteReader())
            {
                while (dataReader.Read())
                {
                    Dictionary<string, object> row = new Dictionary<string,object>(); //实例化一个动态可扩展对象
                    for (int i = 0; i < dataReader.FieldCount; i++)
                    {
                        row.Add(dataReader.GetName(i), dataReader[i]);
                    }
                    yield return row;
                }
            }
        }
    }

    /// <summary>
    /// 执行增、删、改的命令
    /// </summary>
    /// <param name="sql">要执行的SQL语句</param>
    /// <param name="cmdType">SQL语句的类型，默认为文本类型</param>
    /// <param name="parameters">参数</param>
    /// <returns>受影响的行数</returns>
    public static int ExecuteNonQuery(this DbContext dbContext, string sql, CommandType cmdType = CommandType.Text, params DbParameter[] parameters)
    {

        DbConnection conn = dbContext.Database.GetDbConnection();
        if (conn.State != ConnectionState.Open)
        {
            conn.Open(); //打开连接
        }
        // 创建连接对象
        using (var cmd = conn.CreateCommand())
        {
            //接下来把异常处理加入
            try
            {
                cmd.CommandText = sql;
                cmd.CommandType = cmdType;
                //处理输入参数
                cmd.Parameters.AddRange(parameters);

                //事务
                //cmd.Transaction = tran; 

                int result = cmd.ExecuteNonQuery();   //执行增删改命令
                return result;
            }
            catch (Exception ex)
            {
                throw;
            }
        }
    }
}
```

使用：

``` C#
foreach(var a in db.ExecuteSqlQuery("select Price,count(*) as count from T_Article group by Price"))
{
    Console.WriteLine($"{a["Price"]}:{a["count"]}");
}
```

### 使用Dapper

安装包：`NuGet\Install-Package Dapper -Version 2.1.35`

添加要映射的实体类：

``` C#
public class PrinceCountEntity
{
    public double Price { get; set; }
    public int count { get; set; }
}
```

使用Dapper运行SQL语句：

``` C#
foreach(PrinceCountEntity p in db.Database.GetDbConnection().Query<PrinceCountEntity>("select Price,count(*) as count from T_Article group by Price"))
{
    Console.WriteLine($"{p.Price}:{p.count}");
}
```

## 6.10 实体状态（SaveChanges执行的操作）

> 执行SaveChanges时程序是根据实体的状态去对数据库进行增删改的操作。

实体状态：

+ 已添加（Added）：DbContext正在跟踪此实体，但数据库中尚不存在该实体。
+ 未改变（Unchanged）：DbContext正在跟踪此实体，该实体存在于数据库中，其属性值和从数据库中读取到的值一致，未发生改变。
+ 已修改（Modified）：DbContext正在跟踪此实体，并存在于数据库中，并且其部分或全部属性值已修改
+ 已删除（Deleted）：DbContext正在跟踪此实体，并存在于数据库中，但在下次调用SaveChanges时要从数据库中删除对应数据。
+ 已分离（Detached）：DbContext未跟踪此实体。

对于不同的实体状态SaveChanges执行的不同操作：

+ “已分离“和”未改变“的实体：SaveChanges()忽略
+ ”已添加“的实体：SaveChanges()插入数据库
+ ”已修改“的实体：SaveChanges()更新到数据库
+ ”已删除“的实体：SaveChanges()从数据库删除

查看实体状态：

``` C#
var items = db.articles.Take(3).ToArray();
Article a1 = items[0];
Article a2 = items[1];
Article a3 = items[2];
Article a4 = new Article() { Title="a4",Message="xxxx"};
Article a5 = new Article() { Title = "a5", Message = "yyyyy" };

a1.Price += 1;
db.articles.Remove(a2);
db.articles.Add(a4);

EntityEntry e1 = db.Entry(a1);
EntityEntry e2 = db.Entry(a2);
EntityEntry e3 = db.Entry(a3);
EntityEntry e4 = db.Entry(a4);
EntityEntry e5 = db.Entry(a5);

Console.WriteLine(e1.State); // Modified 
Console.WriteLine(e2.State); // Deleted
Console.WriteLine(e3.State); // Unchanged
Console.WriteLine(e4.State); // Added
Console.WriteLine(e5.State); // Detached
```

``` C#
Console.WriteLine(e1.DebugView.LongView); // 输出实体状态的描述信息
// 输出结果
Article {Id: 7} Modified
  Id: 7 PK
  Message: '微软发布。。。'
  Price: 1 Modified Originally 0 // Price的值将从0改为1
  Title: '微软发布....'
  comments: []
```

结论：DbConetxt会根据跟踪的实体的状态，在SaveChanges()的时候，根据实体状态的不同，生成Update、Delete、Insert等SQL语句，来把内存中实体的变化更新到数据库中。

**取消跟踪实体状态（AsNoTracking）**

> 如果确定数据只有查询， 不会被修改、删除等，那么查询的时候可以使用AsNoTracking()，使程序降低内存占用

``` C#
var items = db.articles.AsNoTracking().ToList();
foreach(var item in items)
{
    Console.WriteLine(item.Title);
}
Console.WriteLine(db.Entry(items[0]).State); // Detached 未跟踪状态
```

**实体状态跟踪其他用处**

> 当要修改数据库数据时，如果使用普通的方法修改，会执行两个SQL语句，一个查询一个修改，如果想不执行查询，直接执行修改，就可以通过修改实体跟踪状态来实现

``` C#
// 将id为8的Price改为99
Article article = new Article() { Id = 8,Price=99 };
EntityEntry e1 = db.Entry(article);
e1.Property("Price").IsModified = true;
db.SaveChanges();
// 生成的SQL语句
UPDATE [T_Article] SET [Price] = @p0
      WHERE [Id] = @p1;
```

删除数据时：

``` C#
Article article = new Article() { Id = 8 };
EntityEntry e1 = db.Entry(article);
e1.State = EntityState.Deleted;
db.SaveChanges();
// 生成的SQL
DELETE FROM [T_Article]
      WHERE [Id] = @p0;
```

## 6.11 批量增删改

> 在EF Core （7.0 以前） 中每次进行增删改操作的时候，都是一个实体生成一行SQL语句，如果删除多个的时候，就需要生成多个删除的SQL语句，无法在一行SQL里面实现增删改操作。

这时则可以使用一个包：`Zack.EFCore.Batch.MSSQL_NET6` 不同的EF Core版本需要添加不同的包，具体可以看文档。

操作文档：[Zack.EFCore.Batch/README_CN.md at main · yangzhongke/Zack.EFCore.Batch (github.com)](https://github.com/yangzhongke/Zack.EFCore.Batch/blob/main/README_CN.md)

不同版本的数据库需要添加不同的包：

``` C#
SQLServer: Install-Package Zack.EFCore.Batch.MSSQL_NET6
MySQL: Install-Package Zack.EFCore.Batch.MySQL.Pomelo_NET6
Postgresql: Install-Package Zack.EFCore.Batch.Npgsql_NET6
Sqlite: Install-Package Zack.EFCore.Batch.Sqlite_NET6
Oracle: Install-Package Zack.EFCore.Batch.Oracle_NET6
In Memory(内存数据库)：Install-Package Zack.EFCore.Batch.InMemory_NET6
```

修改DbContext中的`OnConfiguring`方法，添加如下代码：

``` C#
optionsBuilder.UseBatchEF_MSSQL();// MSSQL Server 用户用这个
optionsBuilder.UseBatchEF_Npgsql();//Postgresql 用户用这个
optionsBuilder.UseBatchEF_MySQLPomelo();//MySQL 用户用这个
optionsBuilder.UseBatchEF_Sqlite();//Sqlite 用户用这个
optionsBuilder.UseBatchEF_Oracle();//Oracle 用户用这个
optionsBuilder.UseBatchEF_DM();//DM(达梦) 用户用这个
optionsBuilder.UseBatchEF_InMemory();//In Memory(内存数据库) 用户用这个
```

**批量插入**

``` C#
List<Article> articles = new List<Article>();
for (int i = 0; i < 100; i++)
{
    articles.Add(new Article {Title = Guid.NewGuid().ToString(),Price=i,Message=Guid.NewGuid().ToString() });
}
db.BulkInsert(articles);
```

**批量删除**

``` C#
await db.DeleteRangeAsync<Article>(b => b.Price > 90);
```

**批量修改**

使用DbContext的扩展方法BatchUpdate()来创建一个BatchUpdateBuilder对象。 BatchUpdateBuilder类有如下四个方法：

- Set()方法用于给一个属性赋值。方法的第一个参数是属性的lambda表达式,第二个参数是值的lambda表达式。
- Where() 是过滤条件
- ExecuteAsync()使用用于执行BatchUpdateBuilder的异步方法,Execute()是ExecuteAsync()的同步方法版本。

例子代码:

```
await db.BatchUpdate<Article>()
.Set(b => b.Price, b => b.Price + 3)
.Set(b => b.Title, b => "xxx" + b.Title)
.Where(b => b.Id > 80)
.ExecuteAsync();
```

**在EF Core 7开始，已经可以支持批量删除和批量修改**

这里以EF Core 8演示，首先创建.net 8.0的控制台程序

引用包：

``` C#
<ItemGroup>
  <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.7" />
  <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="8.0.7" />
  <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.7">
    <PrivateAssets>all</PrivateAssets>
    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
  </PackageReference>
  <PackageReference Include="Zack.EFCore.Batch.MSSQL_NET8" Version="8.1.8" />
</ItemGroup>
```

DbContext：

``` C#
public class EFDbContext : DbContext
{
    public DbSet<Article> Articles { get; set; }
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        base.OnConfiguring(optionsBuilder);
        optionsBuilder.LogTo(msg =>
        {
            if (!msg.Contains("CommandExecuting")) return;
            Console.WriteLine(msg);
        });
        optionsBuilder.UseSqlServer("server=.;uid=sa;pwd=sa;database=demo5;Encrypt=True;TrustServerCertificate=True;");
        
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);
    }
}
```

迁移数据库提示：`A connection was successfully established with the server, but then an error occurred during the login process. (provider: SSL Provider, error: 0 - 证书链是由不受信任的颁发机构颁发的。)`时将数据库连接字符串中添加`Encrypt=True;TrustServerCertificate=True;`。

**批量插入（同上）**

``` C#
List<Article> articles = new List<Article>();
for (int i = 0; i < 100; i++)
{
    articles.Add(new Article { Title = Guid.NewGuid().ToString(), Price = i, Message = Guid.NewGuid().ToString() });
}
db.BulkInsert(articles);
```

**批量删除**

``` C#
await db.Articles.Where(t => t.Id > 10).ExecuteDeleteAsync();
```

**批量修改**

``` C#
await db.Articles
.Where(p => p.Id > 5)
.ExecuteUpdateAsync(s => s
    .SetProperty(b => b.Title, b => b.Title + " (" + (DateTime.Now) + ")")
    .SetProperty(b => b.Price, b => b.Price + 5));
```

##  6.12 全局筛选器

> 在使用软删除的时候，所有的查询都需要添加IsDeleted=false这个条件，那么这个条件就可以加到全局条件中

在实体类的配置类中添加：

``` C#
public class ArticleConfig : IEntityTypeConfiguration<Article>
{
    public void Configure(EntityTypeBuilder<Article> builder)
    {
        builder.ToTable("T_Article");
        builder.HasKey(a => a.Id);
        builder.Property(a=>a.Title).HasMaxLength(100).IsRequired();
        builder.Property(a=>a.Message).IsRequired();
        builder.HasMany<Comment>(a => a.comments).WithOne(c => c.Article).HasForeignKey(c=>c.ArticleId);
        builder.HasQueryFilter(a => a.IsDeleted == false); // 全局的过滤条件
    }
}
```

如果在某个查询中不想使用全局筛选器则使用`IgnoreQueryFilters()`

``` C#
foreach(var a in db.articles.IgnoreQueryFilters().Take(10))
{
    Console.WriteLine(a.Id + ":" + a.Title + ":" + a.IsDeleted);
}
```

## 6.13 并发控制

### 悲观并发控制

> 使用MySql的 `select * from T_Article for update` 进行行锁
>
> **悲观并发控制容易出现性能问题。**

创建一个使用MySql数据库的EF Core项目，安装包：

``` C#
NuGet\Install-Package Pomelo.EntityFrameworkCore.MySql -Version 6.0.0
NuGet\Install-Package Microsoft.EntityFrameworkCore.Design -Version 6.0.0
```

DbContext：

``` C#
public class MyDbContext : DbContext
{
    public DbSet<Article> Articles { get; set; }
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        base.OnConfiguring(optionsBuilder);
        var connectionString = "server=localhost;user=root;password=admin;database=demo5";

        var serverVersion = new MySqlServerVersion(new Version(8, 0, 34));
        optionsBuilder.UseMySql(connectionString, serverVersion);
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);
    }
}
```

主程序：

``` C#
static void Main(string[] args)
{
    Console.WriteLine("请输入你的名字：");
    var name = Console.ReadLine();
    using (MyDbContext db = new MyDbContext())
    using(var tx = db.Database.BeginTransaction()) // 开始一个事务
    {
        Console.WriteLine(DateTime.Now + "开始查询");
        var a = db.Articles.FromSqlInterpolated($"select * from t_articles for update").First();
        Console.WriteLine(DateTime.Now + "查询结束");
        if (!string.IsNullOrEmpty(a.Owner))
        {
            if(a.Owner == name)
            {
                Console.WriteLine("DateTime.Now + 已经是你的了");
                Console.ReadKey();
                return;
            }
            else
            {
                Console.WriteLine("DateTime.Now + 已经被【" + a.Owner + "】抢到了") ;
                Console.ReadKey();
                return;
            }
        }
        a.Owner = name;
        Thread.Sleep(5000);
        db.SaveChanges(); // 执行完SaveChanges时 for update 会自动解锁
        tx.Commit(); // 提交事务
        Console.WriteLine(DateTime.Now + "抢到了");
        Console.ReadKey();
    }
}
```

### 乐观并发控制

> 在EF Core 中内置了一种乐观并发控制，通过SQL 语句执行的顺序来进行并发控制，执行的SQL语句如下：
>
> UPDATE `T_Articles` SET `Owner` = @p0
>       WHERE `Id` = @p1 AND `Owner` IS NULL;
>
> 在修改的条件中加入要修改字段的旧值，如果受影响的行数为0则表示并发失败，抛出一个错误：`DbUpdateConcurrencyException`

在实体类的配置中添加：

``` C#
public class ArticleConfig : IEntityTypeConfiguration<Article>
{
    public void Configure(EntityTypeBuilder<Article> builder)
    {
        builder.ToTable("T_Articles");
        builder.Property(a=>a.Owner).IsConcurrencyToken(); // 给Owner字段添加并发令牌
    }
}
```

使用：

``` C#
static void Main(string[] args)
{
    Console.WriteLine("请输入你的名字：");
    var name = Console.ReadLine();
    using (MyDbContext db = new MyDbContext())
    {
        Console.WriteLine(DateTime.Now + "开始查询");
        var a = db.Articles.First();
        Console.WriteLine(DateTime.Now + "查询结束");
        if (!string.IsNullOrEmpty(a.Owner))
        {
            if (a.Owner == name)
            {
                Console.WriteLine("DateTime.Now + 已经是你的了");
            }
            else
            {
                Console.WriteLine("DateTime.Now + 已经被【" + a.Owner + "】抢到了");
            }
            Console.ReadKey();
            return;
        }
        a.Owner = name;
        Thread.Sleep(5000);
        try
        {
            db.SaveChanges();
            Console.WriteLine(DateTime.Now + "抢到了");
        }
        catch (DbUpdateConcurrencyException ex)
        {
            var entry = ex.Entries.First();
            var dbValues = entry.GetDatabaseValues();
            string newOwner = dbValues.GetValue<string>(nameof(Article.Owner));
            Console.WriteLine($"并发控制失败，被【{newOwner}】抢走了");
        }
        Console.ReadKey();
    }
}
// 修改生成的SQL语句
UPDATE `T_Articles` SET `Owner` = @p0
      WHERE `Id` = @p1 AND `Owner` IS NULL;
```

以上代码容易导致ABA问题，虽然改变的值都一样，但是会重复去数据库进行修改

> 以上这个是对一个字段进行并发控制，如果要对一行进行并发控制的话，在MySql中可以添加一个GUID类型的列，然后将这个列设置为并发令牌，**每次对表进行修改时生成一个新的GUID**

``` C#
// 实体类
public class Article
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string? Owner { get; set; }
    public Guid RowVer { get; set; }
}
// 实体类配置类：
public class ArticleConfig : IEntityTypeConfiguration<Article>
{
    public void Configure(EntityTypeBuilder<Article> builder)
    {
        builder.ToTable("T_Articles");
        builder.Property(a=>a.RowVer).IsConcurrencyToken();
    }
}
```

使用：

``` C#
static void Main(string[] args)
{
    Console.WriteLine("请输入你的名字：");
    var name = Console.ReadLine();
    using (MyDbContext db = new MyDbContext())
    {
        Console.WriteLine(DateTime.Now + "开始查询");
        var a = db.Articles.First();
        Console.WriteLine(DateTime.Now + "查询结束");
        if (!string.IsNullOrEmpty(a.Owner))
        {
            if (a.Owner == name)
            {
                Console.WriteLine("DateTime.Now + 已经是你的了");
            }
            else
            {
                Console.WriteLine("DateTime.Now + 已经被【" + a.Owner + "】抢到了");
            }
            Console.ReadKey();
            return;
        }
        a.Owner = name;
        a.RowVer = Guid.NewGuid(); // 生成新的GUID
        Thread.Sleep(5000);
        try
        {
            db.SaveChanges();
            Console.WriteLine(DateTime.Now + "抢到了");
        }
        catch (DbUpdateConcurrencyException ex)
        {
            var entry = ex.Entries.First();
            var dbValues = entry.GetDatabaseValues();
            string newOwner = dbValues.GetValue<string>(nameof(Article.Owner));
            Console.WriteLine($"并发控制失败，被【{newOwner}】抢走了");
        }
        Console.ReadKey();
    }
}
```

**在SQL Server 中可以使用RowVersion**来实现，在表中加入一个timestamp类型的字段，每次对此行的数据进行修改时，都可以生成一个新的版本号

``` C#
// 实体类
public class Article
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string? Owner { get; set; }
    public byte[] RowVer { get; set; }
}
// 实体类配置类
public class ArticleConfig : IEntityTypeConfiguration<Article>
{
    public void Configure(EntityTypeBuilder<Article> builder)
    {
        builder.ToTable("T_Articles");
        builder.Property(a=>a.RowVer).IsRowVersion(); // 配置行版本
    }
}
```

使用（与普通用法一致）：

``` C#
static void Main(string[] args)
{
    Console.WriteLine("请输入你的名字：");
    var name = Console.ReadLine();
    using (MyDbContext db = new MyDbContext())
    {
        Console.WriteLine(DateTime.Now + "开始查询");
        var a = db.Articles.First();
        Console.WriteLine(DateTime.Now + "查询结束");
        if (!string.IsNullOrEmpty(a.Owner))
        {
            if (a.Owner == name)
            {
                Console.WriteLine("DateTime.Now + 已经是你的了");
            }
            else
            {
                Console.WriteLine("DateTime.Now + 已经被【" + a.Owner + "】抢到了");
            }
            Console.ReadKey();
            return;
        }
        a.Owner = name;
        Thread.Sleep(5000);
        try
        {
            db.SaveChanges();
            Console.WriteLine(DateTime.Now + "抢到了");
        }
        catch (DbUpdateConcurrencyException ex)
        {
            var entry = ex.Entries.First();
            var dbValues = entry.GetDatabaseValues();
            string newOwner = dbValues.GetValue<string>(nameof(Article.Owner));
            Console.WriteLine($"并发控制失败，被【{newOwner}】抢走了");
        }
        Console.ReadKey();
    }
}
```

# 7. 表达式树

> Expression 对象存储了运算逻辑，它把运算逻辑保存成抽象语法树（AST），可以在运行时动态获取运算逻辑。而普通委托没有

``` C#
static async Task Main(string[] args)
{
    Expression<Func<Article, bool>> e1 = b => b.Price > 5;
    Expression<Func<Article,Article,double>> e2 = (b1,b2)=> b1.Price + b2.Price;

    Func<Article,bool> f1 = b=>b.Price > 5;
    Func<Article,Article,double> f2 = (b1,b2) => b1.Price + b2.Price;
    // 委托的lambda表达式中可以写方法体，Expression中不可以
    Func<Article, bool> f3 = b => { Console.WriteLine("这是委托中的输出"); return b.Price > 5; }; 

    using(EFDBContent db = new EFDBContent())
    {
        db.articles.Where(e1).ToArray();
        // 生成的sql：
        //SELECT [t].[Id], [t].[IsDeleted], [t].[Message], [t].[Price], [t].[Title]
        // FROM [T_Article] AS [t]
        // WHERE ([t].[IsDeleted] = CAST(0 AS bit)) AND ([t].[Price] > 5.0E0)
        db.articles.Where(f1).ToArray();
        // 生成的sql：
        //SELECT [t].[Id], [t].[IsDeleted], [t].[Message], [t].[Price], [t].[Title]
        // FROM [T_Article] AS [t]
        // WHERE [t].[IsDeleted] = CAST(0 AS bit)
        db.articles.Where(f3).ToArray();
    }

}
```

> Expression可以在进行数据库查询的时候把lambda表达式转换为sql条件
>
> 委托是在数据库查询后，对每条数据进行的操作，在f3中，articles表中有多少条数据，`这是委托中的输出`这句话就会输出多少次

### 7.1 查看表达式树

**安装包：`NuGet\Install-Package ExpressionTreeToString -Version 3.4.71`**

``` C#
Expression<Func<Article, bool>> e1 = b => b.Price > 5;
Expression<Func<Article, Article, double>> e2 = (b1, b2) => b1.Price + b2.Price;
Console.WriteLine(e1.ToString("Object notation","C#"));
Console.WriteLine(e2.ToString("Object notation","C#"));
```

e1的输出：

``` C#
// lambda参数
var b = new ParameterExpression {
    Type = typeof(Article), // article类型
    IsByRef = false,
    Name = "b" // 参数名称
};

new Expression<Func<Article, bool>> {
    NodeType = ExpressionType.Lambda, // 节点的类型是lambda
    Type = typeof(Func<Article, bool>), 
    Parameters = new ReadOnlyCollection<ParameterExpression> { // 参数
        b
    },
    Body = new BinaryExpression { // 主体 
        NodeType = ExpressionType.GreaterThan, // > 节点的类型是 > 号
        Type = typeof(bool), 
        Left = new MemberExpression { // 左子节点 数字类型
            Type = typeof(double), // double类型
            Expression = b, 
            Member = typeof(Article).GetProperty("Price")
        },
        Right = new ConstantExpression { // 右子节点 常量
            Type = typeof(double), // double类型
            Value = 5 
        }
    },
    ReturnType = typeof(bool) // 返回值类型
}
```

e2的输出：

``` C#
var b1 = new ParameterExpression {
    Type = typeof(Article),
    IsByRef = false,
    Name = "b1"
};
var b2 = new ParameterExpression {
    Type = typeof(Article),
    IsByRef = false,
    Name = "b2"
};

new Expression<Func<Article, Article, double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Article, Article, double>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        b1,
        b2
    },
    Body = new BinaryExpression {
        NodeType = ExpressionType.Add,
        Type = typeof(double),
        Left = new MemberExpression {
            Type = typeof(double),
            Expression = b1,
            Member = typeof(Article).GetProperty("Price")
        },
        Right = new MemberExpression {
            Type = typeof(double),
            Expression = b2,
            Member = typeof(Article).GetProperty("Price")
        }
    },
    ReturnType = typeof(double)
}
```

### 7.2 创建表达式树

创建`ParameterExpression、MemberExpression、ConstantExpression、BinaryExpression`等类的时候不能直接new，需要使用`Expression`类提供的工厂方法

``` C#
// 构建一个 Expression<Func<Article, bool>> e1 = b => b.Price > 5; 的表达式树
ParameterExpression parameter = Expression.Parameter(typeof(Article), "b"); // 参数
MemberExpression member = Expression.MakeMemberAccess(parameter, typeof(Article).GetProperty("Price")); // b.Price
ConstantExpression constant = Expression.Constant(5.0, typeof(double)); // 5
BinaryExpression binaryExpression = Expression.GreaterThan(member, constant); // >
Expression<Func<Article,bool>> expression = Expression.Lambda<Func<Article,bool>>(binaryExpression,parameter); // lambda
using (EFDBContent db = new EFDBContent())
{
    db.articles.Where(expression).ToArray(); // 使用构建的表达式树
}
```

其他工厂方法:

| 方法               | 说明             |
| ------------------ | ---------------- |
| Add                | 加法             |
| AndAlso            | 短路与运算       |
| ArrayAccess        | 数组元素访问     |
| Call               | 方法访问         |
| Condition          | 三元条件运算符   |
| Constant           | 常量表达式       |
| Convert            | 类型转换         |
| GreaterThan        | 大于运算符       |
| GreaterThanOrEqual | 大于或等于运算符 |
| MakeBinary         | 创建二元运算     |
| NotEqual           | 不等于运算       |
| OrElse             | 短路或运算       |
| Parameter          | 表达式的参数     |
| LessThan           | 小于运算符       |

**简单的构造表达式树的方法**

> 使用查看表达式树中的包，将`ToString("Object notation","C#")`改为`ToString("Factory methods","C#")`，然后使用输出的代码复制到程序中局部修改即可

``` C#
Expression<Func<Article, bool>> e1 = b => b.Price > 5;
Console.WriteLine(e1.ToString("Factory methods", "C#"));
// 程序的输出
// using static System.Linq.Expressions.Expression

var b = Parameter(
    typeof(Article),
    "b"
);

Lambda(
    GreaterThan(
        MakeMemberAccess(b,
            typeof(Article).GetProperty("Price")
        ),
        Constant(5)
    ),
    b
)
```

使用：

``` C#
using ExpressionTreeToString;
using System.Linq.Expressions;
using static System.Linq.Expressions.Expression; // 添加引用

namespace ExpressionTree
{
    internal class Program
    {

        static async Task Main(string[] args)
        {
            // 参数
            var b = Parameter(
                typeof(Article),
                "b"
            );
			// lambda表达式
            var e1 = Lambda<Func<Article,bool>>( 
                GreaterThan( // 大于运算符
                    MakeMemberAccess(b, // 引用值
                        typeof(Article).GetProperty("Price")
                    ),
                    Constant(5.0) // 常量值
                ),
                b // 参数
            );
            using (EFDBContent db = new EFDBContent())
            {
                db.articles.Where(e1).ToArray();
            }
        }
    }
}
```

### 7.3 动态创建表达式树

> 创建一个方法，方法传递两个参数，第一个参数是字段名称，第二个参数是字段的值，字段的类型是不同的，返回值是一个表达式树

``` C#
static Expression<Func<Article,bool>> GetExpression(string propertyName,object value)
{
    var b = Parameter( // 表达式树的参数
        typeof(Article),
        "b"
    );
    Type valType = typeof(Article).GetProperty(propertyName).PropertyType; // value的类型
    var memberAccessExpr = MakeMemberAccess(b, typeof(Article).GetProperty(propertyName)); // 对比的字段
    var constantExpr = Constant(System.Convert.ChangeType(value, valType)); // 对比的值
    Expression body; // 表达式树的主体
    if(valType.IsPrimitive) // 判断值是否是原始类型
    {
        body = Equal(
            memberAccessExpr,
            constantExpr
        );
    }
    else // 字符串不是原始类型
    {
        body = MakeBinary(ExpressionType.Equal,
            memberAccessExpr,
            constantExpr, false,
            typeof(string).GetMethod("op_Equality")
        );
    }
    return Lambda<Func<Article, bool>>(body, b); // 声明labda表达式树
}
```

使用：

``` C#
var e1 = GetExpression("Price", 5); // 生成的SQL:price=5
e1 = GetExpression("Title", "这是");// 生成的SQL： title='这是'
using (EFDBContent db = new EFDBContent())
{
    db.articles.Where(e1).ToArray();
}
```

**动态列**

> 使用EF Core 查询数据库的时候，默认是查询数据库中所有的列，如果某些列不想查询，可以使用Select的方式来实现
>
> 这里使用表达式树的方式来模拟Seelct方式

写一个泛型方法，方法参数是要查询的列，方法的返回值是一个集合，集合中包含从数据库中查询的结果

``` C#
static IEnumerable<object[]> selectQuery<T>(params string[] propertyNames)
    where T : class // 设置泛型T只能是class类型
{
    var p = Parameter(typeof(T)); // 表达式树参数
    List<Expression> expressions = new List<Expression>(); // 要获取的列的集合
    foreach (var property in propertyNames)
    {
        expressions.Add(
            Convert( // 将列的类型转换为object
                MakeMemberAccess(p,typeof(T).GetProperty(property)),
                typeof(object)
                )
            );
    }
    var arrayExpr = NewArrayInit(typeof(object),expressions.ToArray()); // 创建一个数组，数据为expressions的所有列
    var selectExpr = Lambda<Func<T, object[]>>(arrayExpr, p); // 创建表达式
    using(EFDBContent db = new EFDBContent()) 
    {
        return db.Set<T>().Select(selectExpr).ToArray(); // 从数据库中查询
    }
}
```

使用

``` C#
var items = selectQuery<Article>("Title", "Price");
foreach (var item in items)
{
    Console.WriteLine($"{item[0]},{item[1]}");
}
```

### 7.4 不使用表达式树的方式

> 动态构建表达式树的代码复杂，易读性差，维护困难，一般能不用就不用
>
> 只有在编写不特定于某个实体类的通用框架的时候，由于无法在编译器确定要操作的类名、属性等，所以才需要编写动态构建表达式树的代码。
>
> 否则为了提高代码的可读性和维护性，要尽量避免动态构建表达式树。而是用IQueryable的延迟执行特性来动态构造。

**动态构建条件(使用Linq延迟执行的方式)**

``` C#
static Article[] GetArticles(string title,double? losPrice,double? topPrice,int Orderby)
{
    using (EFDBContent db = new EFDBContent())
    {
        IQueryable<Article> articles = db.articles;
        if(!string.IsNullOrEmpty(title)) // title不为空则判断title
        {
            articles = articles.Where(a=>a.Title == title);
        }
        if(losPrice != null) // 最小值不为空则判断最小值
        {
            articles = articles.Where(a=>a.Price >= losPrice);
        }
        if(topPrice != null) // 最大值不为空则判断最大值
        {
            articles = articles.Where(a=>a.Price <= topPrice);
        }
        switch (Orderby) // 排序
        {
            case 1:
                articles = articles.OrderBy(a => a.Price);
                break;
            case 2:
                articles = articles.OrderByDescending(a => a.Price);
                break;
        }
        return articles.ToArray();
    }
}
// 使用方法
foreach(var a in GetArticles("微软",1,50,1))
{
    Console.WriteLine(a.Title);
}
```

**动态构建条件（System.Linq.Dynamic.Core）**

> 先引用包：`NuGet\Install-Package System.Linq.Dynamic.Core -Version 1.4.3`\

使用：

``` C#
using(EFDBContent db = new EFDBContent())
{
    double price = 5;
    var items = db.articles.Where($"price>{price}");
    foreach ( var item in items )
    {
        Console.WriteLine(item.Title + ": " + item.Price);
    }
}
```

# 8. ASP.NET Core WebAPI

## 8.1 开发风格

### RPC（面向过程）风格

“控制器/操作方法”的形式把服务器的代码当成方法去调用。把HTTP当成传输数据的通道，不关心HTTP谓词。通过QueryString、请求报文体给服务器传递数据。

比如：获取（GET）/user/GetAll、/user/GetById?id=888、/user/GetOderbyuid?uid=888

其他新增用户、修改用户、删除用户都使用POST请求，然后服务器都返回200成功，通过判断服务器发送的msg判断修改是否成功、删除是否成功。 

### REST风格

按照HTTP的语义来使用HTTP协议

1. URL用于资源的定位(GET)：/user/888（获取id为888的用户）、/user/888/orders（获取id为888的用户的所有订单）
2. HTTP谓词的使用场景：GET（获取资源）、POST（新增）、PUT（整体更新）、DELETE（删除）、PATCH（局部更新）等
3. “幂等”**幂等的请求会多次发起**：代码执行多次结果值相等的就是幂等，DELETE、PUT、GET都是幂等的，POST不幂等。
4. GET的响应可以被浏览器缓存
5. 服务器要通过状态码来反映资源获取的结果：404、403（没有权限）、201（新增成功）

REST风格代码：

``` C#
public class UsersController : Controller
{
    /// <summary>
    /// 获取全部用户 GET /Users
    /// </summary>
    /// <returns>用户列表</returns>
    [HttpGet]
    public IEnumerable<User> GetUserAll()
    {
        return new List<User>();
    }
    /// <summary>
    /// 根据用户ID获取用户 GET /Users/888
    /// </summary>
    /// <returns>用户列表</returns>
    [HttpGet("{id}")]
    public IEnumerable<User> GetUserById(string id)
    {
        return new List<User>();
    }
    /// <summary>
    /// 新增用户 POST /Users
    /// </summary>
    /// <returns></returns>
    [HttpPost]
    public IActionResult AddUser(User user)
    {
        return View();
    }
    /// <summary>
    /// 修改用户全部信息 PUT /Users/88
    /// </summary>
    /// <returns></returns>
    [HttpPut("{id}")]
    public IActionResult UpdateUser(string id,User user)
    {
        return View();
    }
    /// <summary>
    /// 修改用户名 PATCH /Users/88
    /// </summary>
    /// <returns></returns>
    [HttpPatch("{id}")]
    public IActionResult UpdateUserName(string id,User user)
    {
        return View();
    }
    /// <summary>
    /// 删除用户 DELETE /Users/88
    /// </summary>
    /// <returns></returns>
    [HttpDelete("{id}")]
    public IActionResult DeleteUser(string id)
    {
        return View();
    }
}
```

**REST优点**

1. 通过URL对资源定位，语义更清晰
2. 通过HTTP谓词表示不同的操作，接口自描述
3. 可以对GET、PUT、DELETE请求进行重试
4. 可以用GET请求做缓存
5. 通过HTTP状态码反映服务器端的处理结果，统一错误处理机制
6. 网关等可以分析请求处理结果

**REST缺点**

1. 真实系统中的资源非常复杂，很难清晰地进行资源的划分，对技术人员的业务和技术水平要求高。
2. 不是所有的操作都能简单地对应到确定的HTTP谓词中
3. 系统的进化可能会改变幂等性
4. 通过URL进行资源定位不符合中文用户的习惯。
5. HTTP状态码个数有限，业务系统中错误数量比较多
6. HTTP的状态码并不适合用来表示业务层面的错误码，它是一个用来表示技术层面信息的状态码。 
7. 有些环节会篡改非200响应码的响应报文（谷歌浏览器404出现小恐龙）
8. 有的客户端不支持PUT、DELETE请求。

### 如何选择

**HTTP传递参数的三种方式**

URL：适合定位；长度限制

QueryString：灵活；长度限制

请求报文体：灵活；长度不限制；不支持GET、DELETE

**三种方式的不同语义**

URL：资源定位

QueryString：URL之外的额外数据

请求报文体：供PUT、POST、PATCH提供数据

**实施指南**

1. 对于保存、更新类的请求使用POST、PUT，把id放到URL中，其他参数放到请求报文体中或全部参数都放到请求报文体中都可以
2. 对于删除的请求使用DELETE，参数使用QueryString或URL传递都可以
3. 对于GET请求，参数参数过长的话可以使用PUT，因为PUT、GET请求都是幂等的。
3. 对于业务错误，服务器端返回合适的状态码，不知道该选择那个就可以使用400，然后在报文体中展示错误信息

### 演示

1. 控制器上添加`[Route("[controller]/[action]")]`
2. 强制要求不同操作使用不同的方法名
3. 把[HttpGet]、[HttpPost]、[HttpDelete]、[HttpPut]等添加到对应的方法上

注意：如果控制器中存在一个没有添加[HttpPost]、[HttpGet]等没有添加谓词的并且是`public`的方法，Swagger就会报错，可以用`[ApiExplorerSettings(IgnoreApi = true)]`

## 8.2 返回值格式

在API项目中，控制器都是继承自`ControllerBase`的，在MVC的项目中，控制器都是继承自`Controller`

`Controller`是继承自`ControllerBase`的，MVC项目中增加了如`View`的方法。

写一个不继承自任何类的控制器：

``` C#
[ApiController]
[Route("[controller]/[action]")]
public class UserController
{
    [HttpGet]
    public ActionResult<int> Get()
    {
        return 88;
    }
}
```

**返回值格式1**

方法应该返回什么类型就写什么类型

``` C#
[HttpGet]
public int Index()
{
    return 88;
}
```

**返回值格式2**

返回`IActionResult`

``` C#
[HttpGet]
public IActionResult Index1(int id)
{
    if(id == 0)
    {
        return NotFound("ID不能为空"); // 返回404 报文体中显示ID不能为空的提示
    }
    return Ok(88); // 需要调用OK方法或JSON等方法将真正的返回值传递到方法中
}
```

> 可以返回错误信息

**返回值格式2 *推荐使用**

返回`ActionResult`

``` C#
[HttpGet]
public ActionResult<int> Index2(int id)
{
    if (id == 0)
    {
        return NotFound("ID不能为空");
    }
    return 88;
}
```

> 返回值会自动做类型转换

### 8.3 请求参数

1. 在[HttpGet]、[HttpPost]等中使用占位符，比如{id}，捕捉url中的内容，给Action提供参数

   > 如果url中的占位符跟action参数名称不同，则需要使用`[FromRoute(Name="占位符名称")]`

2. 使用`FromQuery`来获取QueryString中的值**Action获取参数默认使用此方式，QueryString跟Action参数一致即可获取**

   > 如果名字一致，只需要添加`FromQuery`即可，名字不一致则需要使用`[FromQuery(Name ="名字")]`

3. JSON格式，请求头`Content-Type=application/json`时，Aciton参数可以直接写为一个类，程序会自动将JSON格式的数据转换为类的属性值。

4. 从`Content-Type=multipart/form-data`的请求中获取数据时，使用`[FromForm]`

5. 从请求报文头中获取值使用`[FromHeader]`

**以上方法可以混用**

``` C#
[Route("api/[controller]/[action]")]
[ApiController]
public class ValuesController : ControllerBase
{
    // 使用URL占位符方法
    // https://localhost:7060/api/Values/Get/GetUser/1/School/张三
    [HttpGet("GetUser/{id}/School/{name}")]
    public IActionResult Get(int id,string name)
    {
        return Ok("你好" + id + "," + name);
    }
    // 占位符跟Action参数名称不一致
    // https://localhost:7060/api/Values/Get1/GetUser/1/School/dasff
    [HttpGet("GetUser/{id}/School/{name}")]
    public IActionResult Get1(int id,[FromRoute(Name ="name")]string n)
    {
        return Ok("你好" + id + "," + n);
    }
    // 获取QueryString的值
    // https://localhost:7060/api/Values/Get2?id=123&name=213
    [HttpGet]
    public IActionResult Get2(int id, [FromQuery(Name ="name")]string n)
    {
        return Ok("你好" + id + "," + n);
    }
    // https://localhost:7060/api/Values/Update
    [HttpPut]
    public IActionResult Update(User user)
    {
        return Ok("修改成功：" + user.Id + "," + user.Name);
    }
    // https://localhost:7060/api/Values/Update/12
    [HttpPut("{id}")]
    public IActionResult Update(int id,User user)
    {
        return Ok("修改成功11：" + id + "," + user.Name);
    }
    // 获取请求头中的浏览器信息
    [HttpPut("{id}")]
    public IActionResult Update1(int id, User user, [FromHeader(Name = "User-Agent")]string ua)
    {
        return Ok("修改成功11：" + id + "," + user.Name + "," + ua);
    }
    // 上传文件
    [HttpPost]
    public IActionResult AddOrder([FromForm]Order o)
    {
        return Ok("成功");
    }
}
```

## 8.4 跨域

在.net Core WebAPI中允许跨域：

修改`Program.cs`文件

``` C#
builder.Services.AddCors(option =>
{
    option.AddPolicy("KuaYu", p =>
    {
        p.WithOrigins("http://localhost:8080") // 允许指定的域名
        .AllowAnyHeader() // 允许所有请求头
        .AllowAnyMethod() // 允许所有请求方法
        .AllowCredentials();
    });
});
...
var app = builder.Build();
...
app.UseCors("KuaYu");
```

## 8.5 依赖注入

在.net Core WebAPI中依赖注入不需要自己创建`ServiceCollection`和`ServiceProvider`，直接在`Program.cs`中添加要使用的服务

``` C#
builder.Services.AddScoped<Calculator>();
```

然后在控制器中使用即可：

``` C#
[Route("api/[controller]/[action]")]
[ApiController]
public class DIController : ControllerBase
{
    private readonly Calculator calculator;

    public DIController(Calculator calculator)
    {
        this.calculator = calculator;
    }

    [HttpGet]
    public int Add()
    {
        return calculator.Add(1, 2);
    }
}
```

如果一个服务构造非常耗时，并且在控制器中只有少量方法调用他，则可以使用`[FromService]`，将服务注入到Action中，而不用在控制器的构造方法中注入服务

``` C#
[Route("api/[controller]/[action]")]
[ApiController]
public class DIController : ControllerBase
{
    [HttpGet]
    public int Add([FromServices]Calculator calculator)
    {
        return calculator.Add(1, 2);
    }
}
```

**多个项目服务注册**

在存在多个类库的情况下， 如果使用普通的注册方式，会导致`Program.cs`臃肿，这时可以使用开源项目`Zack.Commons`在每个类库中进行注册。

引用包：`NuGet\Install-Package Zack.Commons -Version 1.1.11`**类库项目和WebAPI项目都需要引用**

在类库项目中需要有一个类继承自`IModuleInitializer`然后在这个类中进行注册服务

``` C#
public class ModuleInit : IModuleInitializer
{
    public void Initialize(IServiceCollection services)
    {
        services.AddScoped<Class1>();
    }
}
```

在WebAPI项目的`Program.cs`中添加如下代码

``` C#
var services = ReflectionHelper.GetAllReferencedAssemblies(); // 获取当前项目所有引用的项目
builder.Services.RunModuleInitializers(services); // 在每个项目中调用服务注册方法
```

## 8.6 缓存

### 浏览器缓存（Cache）

在Action方法中设置`[ResponseCache(Duration =20)]`则表示`cache-control:public,max-age=20`将在浏览器中缓存20秒，20秒内进行下一次请求时浏览器优先从本地缓存中请求，不再访问服务器，超过缓存时间后再对服务器进行请求

``` C#
public class CacheController : ControllerBase
{
    [ResponseCache(Duration =20)] // 缓存20秒
    [HttpGet]
    public DateTime GetDateTime() { return DateTime.Now; }
}
```

### 服务器端缓存（Cache）

浏览器缓存只能在一个浏览器使用，多个浏览器的值是不同的，如果在服务器的`Program.cs`中添加`app.UseResponseCaching();`则可以在服务器端也进行缓存，这样多个浏览器在缓存时间内请求的数据是一致的。

`app.UseResponseCaching();`需要在`app.MapControllers();`之前，并且，在`app.UseCors("KuaYu");`之后。

服务器端缓存缺点：

1. 如果浏览器设置了不可缓存（请求头中添加`cache-control:no-cache`），则不会进行服务器端缓存
2. 响应码为200的GET或者HEAD请求才可能被缓存
3. 报文头中不能包含Authorization、Set-Cookie等。

### 内存缓存

将数据存储到应用程序的内存中，内存缓存中保存的是一系列的键值对，就像Dictionary类型一样。

内存缓存的数据保存在当前运行的网站程序的内存中，是和进程相关的。因为在Web服务器中，多个不同的网站时运行在不同的进程中，所以不同网站的内存缓存时不会互相干扰的。

**内存缓存用法**

1. 启用：`builder.Services.AddMemoryCache();`
2. 在控制器中注入`IMemoryCache`接口
3. 使用`GetOrCreateAsync`或其他方法读取缓存的数据

``` C#
[Route("api/[controller]/[action]")]
[ApiController]
public class CacheController : ControllerBase
{
    private readonly IMemoryCache memoryCache;
    private readonly MyDbContext db;

    public CacheController(IMemoryCache memoryCache, MyDbContext db)
    {
        this.memoryCache = memoryCache;
        this.db = db;
    }

    [ResponseCache(Duration =20)] // 缓存20秒
    [HttpGet]
    public DateTime GetDateTime() { return DateTime.Now; }

    [HttpPost]
    public IActionResult AddDBData(int num) // 添加模拟数据
    {
        Random rnd = new Random();
        string titles = "这是一个大标题你好呀我在呢";
        for (int i = 0; i < num; i++)
        {
            string title = "";
            for(int j = 0; j < rnd.Next(titles.Length); j++)
            {
                title += titles[rnd.Next(titles.Length)];
            }
            db.Books.Add(new Book { Price = Math.Round(rnd.NextDouble(0, 100),2),PubTime = DateTime.Now, Title = title });
        }
        db.SaveChanges();
        return Ok("添加成功");
    }
    
    [HttpGet]
    public async Task<ActionResult<Book?>> GetBookById(int id) // 根据id获取数据
    {
        Console.WriteLine($"开始读取缓存数据{id}");
        // GetOrCreateAsync 从缓存中查找，如果缓存中找不到，则去数据库中找 在数据库中找到后将数据返回给变量并添加到缓存中
        Book? book = await memoryCache.GetOrCreateAsync("book_" + id, async(c) =>
        {
            Console.WriteLine($"缓存不存在，从数据库中读取{id}");
            return db.Books.FirstOrDefault(x => x.Id == id);
        });
        Console.WriteLine($"读取缓存数据结束{id}");
        if (book == null)
        {
            return NotFound($"图书id：{id} 不存在");
        }
        else
        {
            return book;
        }
    }

}
```

#### 缓存过期策略

**手动删除缓存或修改缓存（数据绝对的一致性）**

在数据发生修改时，手动删除或修改缓存中的数据

``` C#
[HttpPut]
public async Task<ActionResult<bool>> UpdateBook(Book book)
{
    Book? b = await db.Books.FirstOrDefaultAsync (b=>b.Id==book.Id);
    if(b!=null)
    {
        b.Title = book.Title;
        //this.memoryCache.Remove("book_" + b.Id); // 手动删除缓存
        this.memoryCache.Set("book_" + b.Id, b); // 如果缓存存在则修改缓存，不存在则新增缓存
        await db.SaveChangesAsync();
        return Ok(true);
    }
    else
    {
        return NotFound($"ID:{book.Id}不存在");
    }
}
```

**绝对时间过期**

当缓存到达指定时间后，自动删除

``` C#
[HttpGet]
public async Task<ActionResult<Book?>> GetBookById(int id) 
{
    Book? book = await memoryCache.GetOrCreateAsync("book_" + id, async(c) =>
    {
        c.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(10); // 设置缓存过期时间为10秒
        return db.Books.FirstOrDefault(x => x.Id == id);
    });
    if (book == null)
    {
        return NotFound($"图书id：{id} 不存在");
    }
    else
    {
        return book;
    }
}
```

**滑动时间过期**

每一次访问后时间都会开始重新计时，如果数据一直被访问，那么缓存就永远不会过期

``` C#
[HttpGet]
public async Task<ActionResult<Book?>> GetBookById(int id)
{
    Book? book = await memoryCache.GetOrCreateAsync("book_" + id, async(c) =>
    {
        c.SlidingExpiration = TimeSpan.FromSeconds(10); // 设置滑动过期时间为10秒
        return db.Books.FirstOrDefault(x => x.Id == id);
    });
    if (book == null)
    {
        return NotFound($"图书id：{id} 不存在");
    }
    else
    {
        return book;
    }
}
```

**绝对时间过期和滑动时间过期混用**

滑动时间过期存在弊端，会导致数据永远不过期，所以可以给数据设置绝对过期时间，当数据到达绝对过期时间后删除缓存

``` C#
[HttpGet]
public async Task<ActionResult<Book?>> GetBookById(int id)
{
    Book? book = await memoryCache.GetOrCreateAsync("book_" + id, async(c) =>
    {
        c.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(10); // 设置绝对过期时间为10秒
        c.SlidingExpiration = TimeSpan.FromSeconds(2); // 设置滑动过期时间为2秒
        return db.Books.FirstOrDefault(x => x.Id == id);
    });
    if (book == null)
    {
        return NotFound($"图书id：{id} 不存在");
    }
    else
    {
        return book;
    }
}
```

#### 缓存穿透

如果给定的id在缓存中不存在，那么会从数据库中查询，如果id在数据库中也不存在，并且用户多次访问，就会一直从数据库中查询，这就是缓存穿透，这时候可以把缓存的值设为null，这样就不用一直去数据库中查询了。

`GetOrCreateAsync`支持将缓存内容设为null

``` C#
public async Task<ActionResult<Book?>> GetBookById(int id) 
{
    Book? book = await memoryCache.GetOrCreateAsync("book_" + id, async(c) =>
    {
        // 从数据库中查询，查询不到返回null
        return db.Books.FirstOrDefault(x => x.Id == id);
    });
    if (book == null)
    {

        return NotFound($"图书id：{id} 不存在");
    }
    else
    {
        return book;
    }
}
```

#### 缓存雪崩

1. 缓存项集中过期引起缓存雪崩
2. 解决办法：在基础过期时间之上，再加上一个随机的过期时间

``` C#
[HttpGet]
public async Task<ActionResult<Book?>> GetBookById(int id)
{
    Book? book = await memoryCache.GetOrCreateAsync("book_" + id, async(c) =>
    {
        c.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(10 + Random.Shared.Next()); // 设置绝对过期时间为10秒 + 一个随机值
        return db.Books.FirstOrDefault(x => x.Id == id);
    });
    if (book == null)
    {
        return NotFound($"图书id：{id} 不存在");
    }
    else
    {
        return book;
    }
}
```

#### 缓存帮助类

在缓存中，如果存储`IEnumerable`或`IQueryable`类型的对象，在读取的时候可能因为延迟加载的问题导致读取不出来，可以禁用存储这两种类型的对象。

使用包`NuGet\Install-Package Zack.ASPNETCore -Version 1.0.2`

包种还封装了随机缓存时间，防止缓存雪崩，随机时间的取值范围是传递的秒数*2

``` C#
// Program.cs 中注入
builder.Services.AddScoped<IMemoryCacheHelper,MemoryCacheHelper>(); // 缓存帮助类

// 控制器中使用
[Route("api/[controller]")]
[ApiController]
public class CaCheHelperController : ControllerBase
{
    private readonly IMemoryCacheHelper memoryCacheHelper;

    public CaCheHelperController(IMemoryCacheHelper memoryCacheHelper)
    {
        this.memoryCacheHelper = memoryCacheHelper;
    }
    [HttpGet]
    public async Task<ActionResult> Get()
    {
        var dt = await memoryCacheHelper.GetOrCreateAsync("dt", async (c) =>
        {
            return DateTime.Now;
        },10); // 设置绝对过期时间（单位/秒），过期时间=Random.Shared.NextDouble(过期时间, 过期时间 * 2)
        return Ok(dt);
    }
}

```

### 分布式缓存（Redis）

Redis只支持存储String或byte[]的值，所以如果存储对象的话，写入的时候用json将对象格式化为字符串，然后读取的时候将字符串转换为对象。

**1. 添加Redis包**

``` C#
NuGet\Install-Package Microsoft.Extensions.Caching.StackExchangeRedis -Version 9.0.0-preview.6.24328.4
```

**2. 在Program.cs中添加引用**

``` C#
builder.Services.AddStackExchangeRedisCache(options => // 添加redis的引用
{
    options.Configuration = "localhost"; // 连接的机器
    options.InstanceName = "memory"; // 起个前缀，防止与其他项目的缓存冲突
});
```

**3. 在控制器中使用**

``` C#
[Route("api/[controller]/[action]")]
[ApiController]
public class RedisController : ControllerBase
{
    private readonly IDistributedCache distributedCache;
    private readonly MyDbContext db;

    public RedisController(IDistributedCache distributedCache, MyDbContext db)
    {
        this.distributedCache = distributedCache;
        this.db = db;
    }
    [HttpGet]
    public async Task<ActionResult> GetTime()
    {
        string? dt = await distributedCache.GetStringAsync("time");
        if(dt == null)
        {
            await distributedCache.SetStringAsync("time", dt=DateTime.Now.ToString());
        }
        return Ok(dt);
    }
    [HttpGet]
    public async Task<ActionResult<Book?>> GetBook(int id)
    {
        Book? b;
        string? str = await distributedCache.GetStringAsync("book_" + id); // 读取缓存
        if(str == null)
        {
            b = await db.Books.FirstOrDefaultAsync(x => x.Id == id); // 从数据库中读取
            await distributedCache.SetStringAsync("book_" + id, // 设置缓存key
                JsonSerializer.Serialize(b), // 格式化要存储的数据
                new DistributedCacheEntryOptions() {  // 过期时间
                    AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(60),  // 绝对过期时间
                    SlidingExpiration= TimeSpan.FromSeconds(10) // 滑动过期时间
                });
        }
        else
        {
            b = JsonSerializer.Deserialize<Book?>(str);
        }
        if(b == null)
        {
            return NotFound($"{id}不存在");
        }
        return Ok(b);
    }
}
```

#### 分布式缓存帮助类

使用包`NuGet\Install-Package Zack.ASPNETCore -Version 1.0.2`

自动做类型转换，添加了`GetOrCreate`方法

在`Program.cs`中添加引用

``` C#
builder.Services.AddScoped<IDistributedCacheHelper,DistributedCacheHelper>();
```

在控制器中使用

``` C#
[Route("api/[controller]")]
[ApiController]
public class DHController : ControllerBase
{
    private readonly IDistributedCacheHelper distributedCacheHelper;

    private readonly MyDbContext db;
    public DHController(IDistributedCacheHelper distributedCacheHelper, MyDbContext db)
    {
        this.distributedCacheHelper = distributedCacheHelper;
        this.db = db;
    }
    [HttpGet]
    public async Task<ActionResult<Book?>> GetBook(int id)
    {
        Book? b = await distributedCacheHelper.GetOrCreateAsync("book_" + id,async (c) => // 读取缓存数据
        {
            Console.WriteLine($"从缓存中读取{id}");
            c.SlidingExpiration = TimeSpan.FromSeconds(5); // 设置滑动过期时间
            return await db.Books.FirstOrDefaultAsync(x => x.Id == id); // 缓存中不存在则从数据库中读取
        },20); // 设置绝对过期时间
       
        if (b == null)
        {
            return NotFound($"{id}不存在");
        }
        return Ok(b);
    }
}
```

## 8.7 配置

ASP.NET Core 默认添加的配置的优先级

1. 加载现有IConfiguration
2. 加载项目根目录下的appsettings.json
3. 加载项目根目录下的appsettings.{Environment}.json
4. 当程序运行在开发环境下，程序会加载“用户机密‘配置
5. 加载环境变量中的配置
6. 加载命令行中的配置

配置的环境问题

1. 开发环境、测试环境、生产环境可以使用不同的配置
2. 程序运行时，ASP.NET Core会从环境变量中读取名字为`ASPNETCORE_ENVIRONMENT`的值，当值为`Development`时会启用开发环境，当值为`Staging`会启用测试环境，当值为`Production`会启用生产环境。
3. 读取方法：`app.Environment.EnvironmentName`或判断是否开发环境`app.Environment.IsDevelopment`，是否测试环境`app.Environment.IsStaging`，是否生产环境`app.Environment.IsProduction`
4. 设置环境变量的方法：Windows 和 VS（推荐开发时用）

**用户机密配置**

为了防止配置文件中的数据库连接字符串等机密在使用git的时候不小心泄露，可以使用用户机密配置，用户机密配置不保存到项目中，所以不会被上传

在vs中右击项目会有一个”管理用户机密“

![image-20240803123022368](学习笔记.assets\image-20240803123022368.png)

点击管理用户机密后，会创建一个配置文件，这个配置文件存储在电脑的其他位置下， 不在项目文件中。

在项目文件(`.csproj`)中会添加一个`<UserSecretsId>22982ecd-efc1-4b05-aa78-c1ff34f59607</UserSecretsId>`，本机的`C:\Users\Administrator\AppData\Roaming\Microsoft\UserSecrets\`目录下会创建一个以项目文件中GUID一致的文件夹，文件夹下创建`secrets.json`,这个文件就是在本机上的用户机密文件了。

**用户机密文件只能在开发环境中使用**

读取用户机密文件的内容，与读取普通配置文件的内容一致

``` C#
Console.WriteLine(app.Configuration.GetSection("ccc").Value);
```

### 中心化配置案例

使用包：`NuGet\Install-Package Zack.AnyDBConfigProvider -Version 1.1.4`

文档地址：[Zack.AnyDBConfigProvider/README_CHS.md at main · yangzhongke/Zack.AnyDBConfigProvider (github.com)](https://github.com/yangzhongke/Zack.AnyDBConfigProvider/blob/main/README_CHS.md)

**1.创建数据库**

``` SQL
create database CenterConfig
go
use CenterConfig
go
create table [T_Configs](
	[Id] [int] IDENTITY(1,1) NOT NULL primary key,
	[Name] [varchar](500) NOT NULL,
	[Value] [varchar](1000) NOT NULL
)
insert into T_Configs(Name,Value) values('Redis','localhost')
insert into T_Configs(Name,Value) values('Mat','{"Server":"ssdfads.com", "Name":"zhangsan","Password":"zhehis2323"}')
```

**2.在项目中创建机密配置**

``` json
{
  "ConnStr": "server=.;uid=sa;pwd=sa;database=CenterConfig;Encrypt=True;TrustServerCertificate=True;"
}
```

**3.引用nuget包**

``` C#
NuGet\Install-Package Zack.AnyDBConfigProvider -Version 1.1.4
NuGet\Install-Package Microsoft.Data.SqlClient -Version 5.2.1
```

redis包如果不用redis就可以不引用

``` C#
NuGet\Install-Package Microsoft.Extensions.Caching.StackExchangeRedis -Version 9.0.0-preview.6.24328.4
```

**4.Program.cs中添加引用**

``` C#
builder.Host.ConfigureAppConfiguration((hostCtx, configBuilder) => {
    string connStr = builder.Configuration.GetSection("ConnStr").Value; // 配置服务器连接字符串
    configBuilder.AddDbConfiguration(() => new SqlConnection(connStr), reloadOnChange: true, reloadInterval: TimeSpan.FromSeconds(2));
});
```

**5.Redis使用**

``` C#
builder.Services.AddSingleton<IConnectionMultiplexer>(sp =>
{
    string connStr = builder.Configuration.GetSection("Redis").Value; // redis连接字符串
    return ConnectionMultiplexer.Connect(connStr);
});
```

**6. 从数据库中读取配置序列化为实体类**

添加一个实体类，对应的是数据库中连接字符串的所有属性

``` C#
public record Mat
{
    public string Server { get; set; }
    public string Name { get; set; }
    public string Password { get; set; }
}
```

在`Program.cs`中注入

``` C#
builder.Services.Configure<Mat>(builder.Configuration.GetSection("Mat")); // 将Mat从数据库中读取出来并转换成Mat对象再注入到程序中
```

**7. 控制器中使用**

``` C#
[Route("api/[controller]")]
[ApiController]
public class CofnigController : ControllerBase
{
    private readonly IOptions<Mat> options; // 读取配置
    private readonly IConnectionMultiplexer connectionMultiplexer; // Redis连接状态
    public CofnigController(IOptions<Mat> options, IConnectionMultiplexer connectionMultiplexer)
    {
        this.options = options;
        this.connectionMultiplexer = connectionMultiplexer;
    }
    [HttpGet]
    public string Get()
    {
        return options.Value.ToString() + connectionMultiplexer.GetDatabase(0).Ping(); // 获取配置 和 读取Redis连接状态
    }
}
```

## 8.8 WebAPI + EF Core

**1. 创建一个WebAPI项目和一个类库项目**

**2. 类库项目细节**

+ 引用包：`NuGet\Install-Package Microsoft.EntityFrameworkCore.Relational -Version 6.0.0` 

+ 创建实体类

+ 创建DbContext，DbContext需要有一个构造方法，参数为`DbContextOptions<MyDbContext>`

  ``` C#
  public class MyDbContext : DbContext
  {
      public DbSet<Book> Books { get; set; }
      public MyDbContext(DbContextOptions<MyDbContext> options) : base(options) { }
      protected override void OnModelCreating(ModelBuilder modelBuilder)
      {
          base.OnModelCreating(modelBuilder);
          modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);
      }
  }
  ```

**3. WebAPI项目中使用**

+ 引用类库项目

+ 添加包：`NuGet\Install-Package Microsoft.EntityFrameworkCore.SqlServer -Version 6.0.0`

+ `Program.cs`中注入

  ``` C#
  builder.Services.AddDbContext<MyDbContext>(options =>
  {
      options.UseSqlServer(builder.Configuration.GetSection("ConnStr").Value); // 从配置中读取连接字符串
  });
  // 连接字符串
  {
      "ConnStr": "server=.;uid=sa;pwd=sa;database=demo11;Encrypt=True;TrustServerCertificate=True;"
  }
  ```

+ 控制器中正常使用即可

**4. 使用`Add-Migraion`、`Update-Database`等方法**

+ 类库项目设为启动项

+ 类库项目引用：`NuGet\Install-Package Microsoft.EntityFrameworkCore.SqlServer -Version 6.0.0`

+ 类库项目引用：`NuGet\Install-Package Microsoft.EntityFrameworkCore.Tools -Version 6.0.0`

+ 类库项目添加实现了`IDesignTimeDbContextFactory`接口的类

  ``` C#
  public class MyDesignTimeDbContextFactory : IDesignTimeDbContextFactory<MyDbContext>
  {
      public MyDbContext CreateDbContext(string[] args)
      {
          DbContextOptionsBuilder<MyDbContext> options = new DbContextOptionsBuilder<MyDbContext>();
          options.UseSqlServer("server=.;uid=sa;pwd=sa;database=demo11;Encrypt=True;TrustServerCertificate=True;"); // 写死连接字符串
          return new MyDbContext(options.Options);
      }
  }
  ```

+ 正常使用`Add-Migration`、`Update-Database`等方法。

#### 批量注册DbContext

如果项目中存在多个DbContext时，每一个都需要在`Program.cs`中进行注册太麻烦了，所以可以使用开源类库进行注册

安装包`NuGet\Install-Package Zack.Infrastructure -Version 1.1.3`

``` C#
// 注册
builder.Services.AddAllDbContexts(options =>
{
    options.UseSqlServer(builder.Configuration.GetSection("ConnStr").Value);
//},new Assembly[] {Assembly.Load("EFCore") }); // 程序集名称 注册单个程序集
},ReflectionHelper.GetAllReferencedAssemblies()); // 程序集名称 注册全部程序集
```

## 8.9 Filter

### 异常处理Filter

在服务器发生未处理的异常的时候，会执行此Filter

**1. 创建一个继承自`IAsyncExceptionFilter`的类**

``` C#
public class LogExceptionFilter : IAsyncExceptionFilter
{
    private readonly IWebHostEnvironment env;

    public LogExceptionFilter(IWebHostEnvironment env)
    {
        this.env = env;
    }

    public Task OnExceptionAsync(ExceptionContext context)
    {
        string msg;
        if (env.IsDevelopment()) // 判断是否是开发环境
        {
            msg = context.Exception.ToString(); // 如果是开发环境则把异常信息转换为字符串
        }
        else
        {
            msg = "服务器发生未处理异常"; // 不是开发环境返回指定字符串
        }
        ObjectResult result = new ObjectResult(new { code = 500, msg = msg }); // 拼接返回值
        context.Result = result; // 设置返回客户端的内容
        context.ExceptionHandled = true; // 当ExceptionHandled为true时，其他异常处理的Filter不再处理
        return Task.CompletedTask;  // 返回一个空

    }
}
```

**2. 在`Program.cs`中进行注册**

``` C#
// 注册异常处理的Filter
builder.Services.Configure<MvcOptions>(options =>
{
    options.Filters.Add<LogExceptionFilter>(); // 后执行
    options.Filters.Add<MyExceptionFilter>(); // 先执行
});
```

> 多个异常处理Filter的注册**顺序在前的是后执行**。
>
> 如果先执行的异常处理Filter将`ExceptionHandled`设置为`True`则后面的异常处理Filter都不会再执行

### ActionFilter

**1. 创建继承自`IAsyncActionFilter`的类**

``` C#
public class ActionFilter1 : IAsyncActionFilter
{
    public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
    {
        Console.WriteLine("Filter1执行前");
        ActionExecutedContext r = await next();
        if(r.Exception != null)
        {
            Console.WriteLine("Filter1执行后 执行失败");
        }
        else
        {
            Console.WriteLine("Filter1执行后 执行成功");
        }
    }
}
public class ActionFilter2 : IAsyncActionFilter
{
    public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
    {

        Console.WriteLine("Filter2执行前");

        ActionExecutedContext r = await next();
        if (r.Exception != null)
        {
            Console.WriteLine("Filter2执行后 执行失败");
        }
        else
        {
            Console.WriteLine("Filter2执行后 执行成功");
        }
    }
}
```

**2. 在`Program.cs`中进行注册**

``` C#
builder.Services.Configure<MvcOptions>(options =>
{
    options.Filters.Add<ActionFilter1>(); // 先执行
    options.Filters.Add<ActionFilter2>(); // 后执行
    options.Filters.Add<LogExceptionFilter>(); // 后执行
    options.Filters.Add<MyExceptionFilter>(); // 先执行
});
```

**执行顺序**

先根据`ActionFilter`注册的顺序**从前往后**执行，如果Action中发生未处理异常后，在执行完`ActionFilter`后再根据异常处理的顺序**从后往前**执行`ExceptionFilter`

![](%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20240805153057364.png)

### 全局事务处理（案例）

**1. 创建不进行事务处理方法的特性**

被此特性修饰的Action将不进行全局事务处理

``` C#
[AttributeUsage(AttributeTargets.Method)] // 只在方法上使用的Attribute
public class NotTranAttribute : Attribute
{
}
```

**2. 创建Filter**

``` C#
public class TranFilter : IAsyncActionFilter
{
    public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
    {
        bool isTran = false; // 是否进行全局事务处理
        if(context.ActionDescriptor is ControllerActionDescriptor) // 判断是否是WebApi/MVC的Action
        {
            ControllerActionDescriptor actionDes = (ControllerActionDescriptor)context.ActionDescriptor; // 转换为WebApi/MVC的Action
            isTran = !actionDes.MethodInfo.GetCustomAttributes(typeof(NotTranAttribute), false).Any();  // 如果Action被NotTranAttribute修饰过，则不进行全局事务处理
        }
        if(isTran)
        {
            using (TransactionScope transactionScope = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled)) // 创建事务 异步
            //using (TransactionScope transactionScope = new TransactionScope()) // 创建事务 同步
            {
                ActionExecutedContext r = await next(); // 获取Action返回值
                if(r.Exception == null) // 如果异常为空则提交事务
                {
                    transactionScope.Complete();
                }
            }
        }
        else
        {
            await next(); // 不进行全局事务处理
        }
    }
}
```

**3. 注册**

``` C#
builder.Services.Configure<MvcOptions>(options =>
{
    options.Filters.Add<TranFilter>();
});
```

**4. 控制器中使用**

``` C#
[Route("api/[controller]/[action]")]
[ApiController]
public class TranController : ControllerBase
{
    private readonly MyDbContext db;

    public TranController(MyDbContext db)
    {
        this.db = db;
    }
    [NotTran]
    [HttpPost]
    public string Add1() // 不使用全局事务处理
    {
        db.Books.Add(new Book { Name = "111",Msg="sssss" }); // 此条数据添加成功
        db.SaveChanges();
        db.Books.Add(new Book { Name = "2222" }); // 此条数据添加失败
        db.SaveChanges();
        return "ok";
    }
    [HttpPost]
    public string Add2() // 使用全局事务处理
    {
        db.Books.Add(new Book { Name = "111", Msg = "sssss" }); // 添加失败
        db.SaveChanges();
        db.Books.Add(new Book { Name = "2222" }); // 添加失败
        db.SaveChanges();
        return "ok";
    }

}
```

### 请求限流器（案例）

**1. 创建一个ActionFilter**

``` C#
public class RateLimitFilter : IAsyncActionFilter
{
    private readonly IMemoryCache memoryCache;

    public RateLimitFilter(IMemoryCache memoryCache)
    {
        this.memoryCache = memoryCache;
    }

    public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
    {
        string ip = context.HttpContext.Connection.RemoteIpAddress.ToString(); // 客户端IP地址
        string cacheKey = $"ip_{ip}"; // 拼接key
        long? lastTick = memoryCache.Get<long?>(cacheKey); // 根据key从缓存中取出上次访问时间
        if (lastTick == null || Environment.TickCount64 - lastTick > 1000) // 如果key等于空或者当前时间-上次访问时间大于1000毫秒
        {
            memoryCache.Set(cacheKey, Environment.TickCount64, TimeSpan.FromSeconds(3)); // 更新最后一次访问时间
            await next(); // 进入下一个Filter或进入Action
        }
        else // 否则返回访问太频繁了
        {
            ObjectResult r = new ObjectResult("访问太频繁了") { StatusCode = 429 };
            context.Result = r;
        }
    }
}
```

**2. 在`Program.cs`中注册**

``` C#
builder.Services.AddMemoryCache();
// 注册异常处理的Filter
builder.Services.Configure<MvcOptions>(options =>
{
    options.Filters.Add<RateLimitFilter>();
});
```

# 9. 中间件

中间件是ASP.NET Core 的核心组件，MVC框架、响应缓存、身份验证、CORS、Swagger等都是内置中间件

ASP.NET Core 的工作流程

![image-20240805171248491](%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20240805171248491.png)

中间件由前逻辑、next、后逻辑3部分组成，前逻辑为第一段要执行的逻辑代码、next为指向下一个中间件的调用、后逻辑为从下一个中间件执行返回所执行的逻辑代码。每个HTTP请求都要经历一系列中间件的处理，每个中间件对于请求进行特定的处理后，再转到下一个中间件，最终的业务逻辑代码执行完成后，响应的内容也会按照处理的想反顺序进行处理，然后形成HTTP响应报文返回给客户端。

中间件组成一个管道，整个ASP.NET Core的执行过程就是HTTP请求和响应按照中间件组装的顺序在中间件之间流转的过程。开发人员可以对组成管道的中间件按照需要进行自由组合。

**中间件的三个概念**

Map、Use和Run。Map用来定义一个管道可以处理那些请求，Use和Run用来定义管道，一个管道由若干个Use和一个Run组成，每个Use引入一个中间件，而Run是用来执行最终的核心应用逻辑。

![image-20240805171901707](%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20240805171901707.png)

## 9.1 第一个中间件程序

**1. 创建一个项目，项目模板选择`ASP.NET Core 空项目`**

**2. 修改`Program.cs`文件**

> **微软不允许在中间件中写返回的数据，只能在Run中写**

``` C#
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.Map("/test", async appBuilder =>
{
    appBuilder.Use(async (context, next) =>
    {
        context.Response.ContentType = "text/html";
        await context.Response.WriteAsync("1. Start<br/>");
        await next.Invoke();
        await context.Response.WriteAsync("1. End<br/>");
    });
    appBuilder.Use(async (context, next) =>
    {
        await context.Response.WriteAsync("2. Start<br/>");
        await next.Invoke();
        await context.Response.WriteAsync("2. End<br/>");
    });
    appBuilder.Run(async context =>
    {
        await context.Response.WriteAsync("Run<br/>");
    });
});

app.Run();

```

**3. 浏览器中访问`https://localhost:7230/test`**

## 9.2 中间件类

中间件类是一个普通的.NET类，它不需要继承任何父类或实现任何接口。

但是这个类需要有一个构造方法，构造方法的参数至少有一个`RequestDelegate`，这个参数用来指向下一个中间件。

这个类还需要定义一个名字为`Invoke`或`InvokeAsync`的方法，方法至少有一个`HttpContext`类型的参数，方法返回值必须是Task类型。

中间件类的构造方法和Invoke（InvokeAsync）方法还可以定义其他参数，其他参数的值会通过依赖注入自动赋值

**1. 定义一个中间件类**

``` C#
public class CheckMiddleware
{
    private readonly RequestDelegate next;  

    public CheckMiddleware(RequestDelegate next) // 中间件类必须有一个参数为RequestDelegate的构造方法
    {
        this.next = next;
    }
    public async Task InvokeAsync(HttpContext context) // 中间件类必须由返回值为Task，名称为：InvokeAsync，参数有：HttpContext的方法
    {
        string pwd = context.Request.Query["password"]; // 获取QueryString中为password的值
        if(pwd == "123") // 如果值为123
        {
            if (context.Request.HasJsonContentType()) // 如果请求的Body为JSON格式
            {
                var reqStream = context.Request.BodyReader.AsStream(); // 获取请求体
                dynamic? obj = DJson.Parse(reqStream); // 保存为dynamic格式
                context.Items["BodyJson"] = obj; // 保存到Items中，Items中的数据在一个请求中其他所有中间件和Run方法都可以使用
            }
            await next(context);
        }
        else // 否则返回401错误
        {
            context.Response.StatusCode = 401;
        }

    }
}
```

**2. 在`Program.cs`中使用**

``` C#
app.Map("/test", async appBuilder =>
{
    appBuilder.UseMiddleware<CheckMiddleware>(); // 注册中间件类
    appBuilder.Use(async (context, next) =>
    {
        context.Response.ContentType = "text/html";
        await context.Response.WriteAsync("1. Start<br/>");
        await next.Invoke();
        await context.Response.WriteAsync("1. End<br/>");
    });
    appBuilder.Use(async (context, next) =>
    {
        await context.Response.WriteAsync("2. Start<br/>");
        await next.Invoke();
        await context.Response.WriteAsync("2. End<br/>");
    });
    appBuilder.Run(async context =>
    {
        await context.Response.WriteAsync("Run<br/>");
        dynamic? d = context.Items["BodyJson"]; // 使用中间件类中添加的请求体数据
        if(d != null)
        {
            await context.Response.WriteAsync($"{d}<br/>");
        }

    });
});
```

## 9.3 Markdown中间件（案例）

**1. 创建一个`ASP.NET Core Web 应用`项目 并在项目的wwwroot目录下放一个1.md文件**

引用包：

``` shell
NuGet\Install-Package Ude.NetStandard -Version 1.2.0
NuGet\Install-Package Markdig -Version 0.37.0
```

1.md文件：

``` markdown
## 一 Node开发微信公众号
#### 1.1 快速开始
此时只需要微信的签名校验通过即可回复，第三方包wechat已经处理好了签名。
```javascript
const express = require('express');
const wechat = require('wechat');

let app = express();

const myConfig = {
    appid: '',
    appsecret: '',
    token: '',
    encodingAESKey: ''
};

```

**2. 创建中间件类**

``` C#
public class MarkdownMiddleware
{
    private readonly RequestDelegate next; // 下一个中间件或Run方法
    private readonly IWebHostEnvironment env; // 获取wwwroot内容用

    public MarkdownMiddleware(RequestDelegate next, IWebHostEnvironment env)
    {
        this.next = next;
        this.env = env;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        string path = context.Request.Path.ToString(); // 获取url中的路径
        if (!path.EndsWith(".md")) // 如果路径不是以md结尾则进入下一个中间件
        {
            await next(context);
            return;
        }
        var file = env.WebRootFileProvider.GetFileInfo(path); // 根据路径从wwwroot中获取文件信息
        
        if(!file.Exists) // 如果文件不存在则进入下一个中间件
        {
            await next(context);
            return;
        }
        using(var stream = file.CreateReadStream()) // 文件存在则创建文件读取流
        {
            Ude.CharsetDetector cdet = new Ude.CharsetDetector(); // 根据文件流获取编码格式
            cdet.Feed(stream);
            cdet.DataEnd();
            string charset = cdet.Charset??"UTF-8"; // 如果编码格式为空则使用默认的UTF-8
            stream.Position = 0; // 复位流
            using (var reader = new StreamReader(stream, Encoding.GetEncoding(charset))) // 获取文件内容
            {
                string md = reader.ReadToEnd(); // md文件的内容
                string html = Markdown.ToHtml(md); // 转换为html格式
                context.Response.StatusCode = 200; // 响应码
                context.Response.ContentType = "text/html;charset=UTF-8"; // 响应格式
                await context.Response.WriteAsync(html); // 响应内容
            }

        }
    }
}
```

**3. 在`Program.cs`中进行注册(需要在`app.UseStaticFiles();`之前)**

``` C#
app.UseHttpsRedirection();
app.UseMiddleware<MarkdownMiddleware>(); // 注册markdown中间件
app.UseStaticFiles();
```

**4. 在浏览器中访问`https://localhost:7010/1.md`**

## 9.4 自定义WebApi中间件（案例）

**1. 创建一个`ASP.NET Core 空`项目**

**2. 添加工具类**



``` C#
/// <summary>
/// 路径解析
/// </summary>
public class PathParser
{
    /// <summary>
    /// 根据路径解析控制器和Action名称
    /// </summary>
    /// <param name="pathString"></param>
    /// <returns>解析成功则返回true、控制器名称、Action名称</returns>
    /// <returns>解析失败则返回false、null、null</returns>
    public static (bool ok,string? controllerName,string? actionName) Parse(PathString pathString)
    {
        string? path = pathString.Value; // 获取路径
        if(path == null ) // 路径为空
        {
            return (false, null, null);
        }
        var match = Regex.Match(path, "/([a-zA-Z0-9]+)/([a-zA-Z0-9]+)"); // 解析
        if(!match.Success) // 解析失败
        {
            return (false,null,null);
        }
        string controllerName = match.Groups[1].Value; // 控制器名称
        string actionName = match.Groups[2].Value; // Action名称
        return (true, controllerName, actionName); 
    }
}
```

``` C#
/// <summary>
/// 定位Action
/// </summary>
public class ActionLocator
{
    private Dictionary<string,MethodInfo> data = new(StringComparer.OrdinalIgnoreCase); // 存储所有的Action，key为：控制器名称.Action名称
    public ActionLocator(IServiceCollection services,Assembly assemblyWeb)  // 初始化控制器
    {
        var controllerTypes = assemblyWeb.GetTypes().Where(IsControllerType); // 通过反射获取当前项目中所有的控制器
        foreach (var controllerType in controllerTypes) // 循环所有的控制器
        {
            services.AddScoped(controllerType); // 将控制器注册到服务中
            int index = controllerType.Name.LastIndexOf("Controller"); 
            string controllerName = controllerType.Name.Substring(0, index); // 去掉控制器后缀
            var methods = controllerType.GetMethods(BindingFlags.Public| BindingFlags.Instance); // 获取控制器中所有的公开的方法
            foreach (var method in methods) // 循环所有的方法
            {
                string actionName = method.Name;
                data[$"{controllerName}.{actionName}"] = method; // 添加到data中
            }
        }
    }

    /// <summary>
    /// 判断是否是控制器
    /// </summary>
    /// <param name="t"></param>
    /// <returns></returns>
    private static bool IsControllerType(Type t)
    {
        // 是个类 并且 不是抽象类 并且 以Controller结尾
        return t.IsClass && !t.IsAbstract && t.Name.EndsWith("Controller");
    }

    public MethodInfo? LocateActionMethod(string controllerName,string actionName)
    {
        string key = $"{controllerName}.{actionName}"; // 拼接key
        data.TryGetValue(key, out MethodInfo? method); // 从data中获取
        return method; // 返回
    }

}
```

``` C#
/// <summary>
/// 完成请求报文到操作方法参数的绑定
/// </summary>
public class BindingHelper
{
    /// <summary>
    /// 在actionMethod中读取方法所需要的参数列表
    /// 从httpContext请求中读取参数
    /// </summary>
    /// <returns>传递给操作方法的参数值</returns>
    /// <exception cref="Exception"></exception>
    public static object?[] GetParameterValues(HttpContext context,MethodInfo actionMethod)
    {
        var parameters = actionMethod.GetParameters(); // 获取参数列表
        if(parameters.Length <= 0) // 如果参数小于等于0则返回一个0
        {
            return new object?[0];
        }else if (parameters.Length > 1) // 如果参数大于1则抛出异常
        {
            throw new Exception("Action参数只能为0或者1个");
        }
        if(parameters.Single().ParameterType == typeof(HttpContext)) { // 如果参数是HttpContext类型则直接传递
            return new object?[] { context };
        }
        // 如果参数不是json格式抛出异常
        if(!context.Request.HasJsonContentType())
        {
            throw new Exception("Action如果只有一个参数，则ContentType必须是appliaction/json");
        }
        // 如果请求报文体为空则绑定参数值为null
        if(context.Request.ContentLength == 0)
        {
            return new object?[1] { null };
        }
        // 获取参数流
        var reqStream = context.Request.BodyReader.AsStream();
        // 参数的类型
        Type paramType = parameters.Single().ParameterType;
        // 反序列化参数 将json字符串序列化为参数所需的类型
        object? paramValue = JsonSerializer.Deserialize(reqStream, paramType);
        // 返回绑定的参数
        return new object?[1] { paramValue };
    }
}
```

``` C#
/// <summary>
/// Filter 要实现的接口
/// </summary>
public interface IActionFilter
{
    void run();
}
```

``` C#
/// <summary>
/// Filter组件
/// </summary>
public class ActionFilters
{
    // WebApi中所有的Filter
    public static List<IActionFilter> Filters = new List<IActionFilter>();
}
```

``` C#
/// <summary>
/// 合法静态文件类
/// </summary>
public class ContentTypeHelper
{
    // 文件后缀名和返回的类型
    private static readonly Dictionary<string, string> data = new(StringComparer.OrdinalIgnoreCase);
    static ContentTypeHelper()
    {
        data[".html"] = "text/html; charset=utf-8";
        data[".htm"] = "text/html; charset=utf-8";
        data[".txt"] = "text/plain; charset=utf-8";
        data[".jpg"] = "image/jpeg";
        data[".jpeg"] = "image/jpeg";
        data[".png"] = "image/png";
        data[".js"] = "application/x-javascript; charset=utf-8";
        data[".css"] = "text/css";
    }

    /// <summary>
    /// 判断是否是合法的静态文件
    /// </summary>
    /// <param name="file"></param>
    /// <returns></returns>
    public static bool IsValid(IFileInfo file)
    {
        if(file.IsDirectory) // 判断是否是文件夹
        {
            return false;
        }
        string extension = Path.GetExtension(file.Name); // 获取文件后缀名
        return data.ContainsKey(extension); // 文件后缀名在data中存在
    }
    
    /// <summary>
    /// 获取文件对应的ContentType
    /// </summary>
    /// <param name="file"></param>
    /// <returns></returns>
    public static string GetContentType(IFileInfo file)
    {
        string extension = Path.GetExtension(file.Name); // 文件后缀名
        return data[extension];
    }
}
```

``` C#
public class MyFilter : IActionFilter
{
    public void run()
    {
        Console.WriteLine("中间件执行了");
    }
}
```



**3. 编写WebApi中间件**

``` C#
public class MyWebAPIMiddleware
{
    private readonly RequestDelegate next; // 下一个中间件
    private readonly ActionLocator locator; // 获取Action方法和判断类是否是控制器类
    public MyWebAPIMiddleware(RequestDelegate next, ActionLocator locator)
    {
        this.next = next;
        this.locator = locator;
    }
    public async Task InvokeAsync(HttpContext context,IServiceProvider sp)
    {
        (bool ok,string? ctrlName,string? actionName) = PathParser.Parse(context.Request.Path); // 获取控制器名称和Action名称
        if(ok == false) // 获取失败则进入下一个中间件
        {
            await next(context);
            return;
        }
        MethodInfo? method = locator.LocateActionMethod(ctrlName!, actionName!); // 根据控制器和Action名称获取实际要执行的方法
        if(method == null) // 没有找到要执行的方法则进入下一个中间件
        {
            await next(context);
            return;
        }
        
        Type controllerType = method.DeclaringType!;
        object controllerInstance = sp.GetRequiredService(controllerType);

        // 获取参数
        var paraValues = BindingHelper.GetParameterValues(context, method);

        // 调用Filter
        foreach( IActionFilter filter in ActionFilters.Filters)
        {
            filter.run();
        }
        // 执行方法并获取返回值
        var result = method.Invoke(controllerInstance, paraValues);
        // 序列化返回值为json字符串
        string jsonStr = JsonSerializer.Serialize(result);
        context.Response.StatusCode = 200;
        context.Response.ContentType = "application/json;charset=utf-8";
        await context.Response.WriteAsync(jsonStr);

    }
}
```

**4. 404中间件**

``` C#
/// <summary>
/// 404中间件
/// </summary>
public class NotFoundMiddleware
{
    private readonly RequestDelegate next;

    public NotFoundMiddleware(RequestDelegate next)
    {
        this.next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        context.Response.StatusCode = 404;
        context.Response.ContentType = "text/html;charset=utf-8";
        await context.Response.WriteAsync("访问的请求不存在");
    }
}
```

**5. 静态文件中间件**

``` C#
/// <summary>
/// 静态文件中间件
/// </summary>
public class MyStaticFilesMiddleware
{
    private readonly RequestDelegate next;
    private readonly IWebHostEnvironment env; 

    public MyStaticFilesMiddleware(RequestDelegate next, IWebHostEnvironment env)
    {
        this.next = next;
        this.env = env;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        string path = context.Request.Path.Value ?? ""; // 获取url
        var file = env.WebRootFileProvider.GetFileInfo(path); // 根据url从本地中查找文件
        if(!file.Exists || !ContentTypeHelper.IsValid(file)) // 文件不存在或文件类型不正确进入下一个中间件
        {
            await next(context);
            return;
        }
        context.Response.ContentType = ContentTypeHelper.GetContentType(file); // 设置文件返回类型
        context.Response.StatusCode = 200; // 响应码
        using(var stream = file.CreateReadStream()) // 获取文件流
        {
            byte[] bytes=  await ToArrayAsync(stream); // 转换
            await context.Response.Body.WriteAsync(bytes);
        }
    }

    /// <summary>
    ///  将文件流转换为byte数组
    /// </summary>
    /// <param name="stream"></param>
    /// <returns></returns>
    public static async Task<byte[]> ToArrayAsync(Stream stream)
    {
        using(MemoryStream memoryStream = new MemoryStream())
        {
            await stream.CopyToAsync(memoryStream);
            memoryStream.Position = 0;
            byte[] bytes = memoryStream.ToArray();
            return bytes;
        }
    }
}
```

**6. `Pargram.cs`中注册**

``` C#
var builder = WebApplication.CreateBuilder(args);

ActionFilters.Filters.Add(new MyFilter()); // 注册filter

// 初始化所有的控制器和Action方法
ActionLocator locator = new ActionLocator(builder.Services,Assembly.GetEntryAssembly()!);
builder.Services.AddSingleton(locator); // 注册服务
builder.Services.AddMemoryCache(); // 注册缓存服务

var app = builder.Build();

app.UseMiddleware<StaticFileMiddleware>(); // 静态文件中间件
app.UseMiddleware<MyWebAPIMiddleware>(); // 自定义的WebApi中间件
app.UseMiddleware<NotFoundMiddleware>(); // 404中间件

app.Run();
```

**7. 控制器中使用**

``` C#
public class Test1Controller
{
    private IMemoryCache memoryCache;

    public Test1Controller(IMemoryCache memoryCache)
    {
        this.memoryCache = memoryCache;
    }
    public User GetUser(User user)
    {
        return user;
    }
    public object[] Get2(HttpContext ctx)
    {
        DateTime now = memoryCache.GetOrCreate("now", e => DateTime.Now);
        string name = ctx.Request.Query["name"];
        return new object[] { now, name };
    }
    
}
public record User(string Name,string Pwd);
```

> 没有使用请求方法限制，所以test1/GetUser和test1/Get2可以使用GET、POST、DELETE等都可以访问
>
> 还可以在wwwroot下放静态文件，使用/a.png可以访问到静态文件。

## 9.5中间件和Filter的区别

**关系**

中间件是ASP.NET Core这个基础提供的功能，而Filter是ASP.NET Core MVC中提供的功能。ASP.NET Core MVC是由MVC中间件提供的框架，而Filter属于MVC中间件提供的功能。

![image-20240806153511152](%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20240806153511152.png)

**区别**

1. 中间件可以处理所有的请求，而Filter 只能处理对控制器的请求；中间件运行在一个更底层、更抽象的级别，因此在中间件中无法处理MVC中间件特有的概念。
2. 中间件和Filter 可以完成很多相似的功能。“未处理异常中间件“和”未处理异常Filter“的区别在于“未处理异常中间件”可以处理程序中其他中间件产生的未处理异常，“未处理异常Filter”只能处理MVC中的未处理异常，”请求限流中间件“可以对静态文件也进行限流，”请求限流Filter”只能对Action请求限流。
3. 在能完成相同功能的情况下，**优先使用中间件**，但是如果这个组件只针对MVC或者需要调用一些MVC相关的类的时候，就只能使用Filter了。

# 10. 高级开发

## 10.1 Identity使用

**1. 安装包**

``` C#
NuGet\Install-Package Microsoft.AspNetCore.Identity.EntityFrameworkCore -Version 6.0.0
NuGet\Install-Package Microsoft.EntityFrameworkCore.SqlServer -Version 6.0.0
NuGet\Install-Package Microsoft.EntityFrameworkCore.Tools -Version 6.0.0
```

**2. 创建用户类**

``` C#
// 用户
public class MyUser : IdentityUser<long>
{
}
```

**3. 创建角色类**

``` C#
// 角色
public class MyRole : IdentityRole<long>
{
}
```

**4. 创建DbContext**

``` C#
public class MyDbContext : IdentityDbContext<MyUser,MyRole,long>
{
    public MyDbContext(DbContextOptions options)
    : base(options)
    {
    }
}
```

**5. `Program.cs`中注册**

``` C#

builder.Services.AddDbContext<MyDbContext>(option => // 注入DbContext
{
    option.UseSqlServer("server=.;uid=sa;pwd=sa;database=demo12;");
});
builder.Services.AddDataProtection();
builder.Services.AddIdentityCore<MyUser>(option =>
{
    option.Lockout.MaxFailedAccessAttempts = 5; // 登录失败几次后锁定账号
    option.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(5); // 账号锁定时间 5分钟
    option.Password.RequireDigit = false; // 是否必须包含数字
    option.Password.RequireLowercase = false; // 是否要求小写字母
    option.Password.RequireNonAlphanumeric = false; // 是否要求非数字非字母
    option.Password.RequireUppercase = false; // 是否要求大写字母
    option.Password.RequiredLength = 6; // 密码长度
	option.Tokens.PasswordResetTokenProvider = TokenOptions.DefaultEmailProvider; // 重置密码时候的token格式，默认为特别复杂
    option.Tokens.EmailConfirmationTokenProvider = TokenOptions.DefaultEmailProvider;
});
var idBuilder = new IdentityBuilder(typeof(MyUser), typeof(MyRole), builder.Services);
idBuilder.AddEntityFrameworkStores<MyDbContext>()
    .AddDefaultTokenProviders()
    .AddRoleManager<RoleManager<MyRole>>()
    .AddUserManager<UserManager<MyUser>>();
```

**6. 迁移数据库**

``` C#
add-migration init
update-database
```

**7 . 控制器中使用**

``` C#
[Route("api/[controller]/[action]")]
[ApiController]
public class HomeController : ControllerBase
{
    private readonly UserManager<MyUser> userManager;
    private readonly RoleManager<MyRole> roleManager;
    private readonly IWebHostEnvironment webHostEnvironment;

    public HomeController(UserManager<MyUser> userManager, RoleManager<MyRole> roleManager, IWebHostEnvironment webHostEnvironment)
    {
        this.userManager = userManager;
        this.roleManager = roleManager;
        this.webHostEnvironment = webHostEnvironment;
    }
    [HttpPost]
    public async Task<ActionResult> Post()
    {
        if(await roleManager.RoleExistsAsync("admin") == false) // 判断角色是否存在
        {
            IdentityResult result = await roleManager.CreateAsync(new MyRole { Name = "admin" }); // 如果角色不存在则创建角色
            if(!result.Succeeded) // 判断方法执行的返回值，返回值如果不成功
            {
                if(webHostEnvironment.IsDevelopment()) // 开发环境下输出错误
                {
                    return BadRequest(result.Errors);
                }
                else // 其他环境下输出 方法执行错误
                {
                    return BadRequest("roleManager.CreateAsync 方法执行错误");
                }
            }
        }
        MyUser? user = await userManager.FindByNameAsync("shl"); // 获取用户
        if (user == null) // 如果用户为空则创建用户
        {
            user = new MyUser { UserName = "shl" }; // 创建用户
            IdentityResult result = await userManager.CreateAsync( // 将用户添加到数据库中
                user, // 指定要添加的用户
                "123456"); // 指定用户密码
            if (!result.Succeeded)
            {
                return BadRequest("userManager.CreateAsync 方法执行错误");
            }
        }
        if (await userManager.IsInRoleAsync(user,"admin") == false) // 判断用户是否用用admin角色
        {
            IdentityResult result = await userManager.AddToRoleAsync(user, "admin"); // 给用户添加角色
            if (!result.Succeeded) // 方法执行是否成功
            {
                return BadRequest("userManager.AddToRoleAsync 方法执行错误");
            }
        }
        return Ok("添加成功");
    }
    [HttpPost]
    public async Task<ActionResult> Login(UserLogin u)
    {
        var user = await userManager.FindByNameAsync(u.userName); // 根据用户名查找用户
        if (user == null) // 用户不存在
        {
            return BadRequest("用户名或密码错误");
        }
        if (await userManager.IsLockedOutAsync(user)) // 用户是否被锁定
        {
            return BadRequest($"账户被锁定，解锁时间：{user.LockoutEnd}"); // 如果用户被锁定则提示用户已被锁定
        }
        if (await userManager.CheckPasswordAsync(user, u.paddword) ==false) // 判断密码是否不正确
        {
            if (!(await userManager.AccessFailedAsync(user)).Succeeded) // 登录失败，设置登录失败次数
            {
                return BadRequest("服务器发生错误");
            }
            return BadRequest("用户名或密码错误");
        }
        IdentityResult result = await userManager.ResetAccessFailedCountAsync(user); // 登录成功，重置登录失败次数
        if (!result.Succeeded)
        {
            return BadRequest("服务器发生错误");
        }
        return Ok("登录成功");
    }
}
```

**重置密码功能**

``` C#
[Route("api/[controller]/[action]")]
[ApiController]
public class ResetPasswordController : ControllerBase
{

    private readonly UserManager<MyUser> userManager;
    private readonly RoleManager<MyRole> roleManager;

    public ResetPasswordController(UserManager<MyUser> userManager, RoleManager<MyRole> roleManager)
    {
        this.userManager = userManager;
        this.roleManager = roleManager;
    }
    [HttpPost]
    public async Task<ActionResult> GetCode(string name) // 获取token
    {
        MyUser? user = await userManager.FindByNameAsync(name);
        if (user == null) // 用户不存在
        {
            return BadRequest("用户名不存在");
        }
        string token = await userManager.GeneratePasswordResetTokenAsync(user); // 获取重置密码的token
        Console.WriteLine(token); // 将token输出到控制台
        return Ok();
    }
    [HttpPatch]
    public async Task<ActionResult> ResetPassword(string name,string token,string pwd)
    {
        MyUser? user = await userManager.FindByNameAsync(name);
        if (user == null) // 用户不存在
        {
            return BadRequest("用户名不存在");
        }
        if((await userManager.ResetPasswordAsync(user, token, pwd)).Succeeded == false) // 重置密码
        {
            await userManager.AccessFailedAsync(user);
            return BadRequest("重置密码失败");
        }
        else
        {
            await userManager.ResetAccessFailedCountAsync(user);
            return Ok("重置密码成功");
        }
    }
}
```

## 10.2 JWT

使用包：`NuGet\Install-Package System.IdentityModel.Tokens.Jwt -Version 8.0.1`

1. JWT把登录信息（令牌）保存在客户端
2. 为了防止客户端的数据造假，保存在客户端的令牌经过了签名处理，而签名的密钥只有服务器端知道，每次服务器端收到客户端提交过来的令牌的时候都要检查一下签名
3. 客户端存储的三个信息：
   1. 头部Header{"alg":"hmac-sha256","typ":"JWT"}
   2. 负载Payload{"id":"6","name":"admin"}
   3. 签名Signature{HMACSHA256(header+payload+secKey)}

**JWT优点**

1. 状态保存在客户端，而非服务器端。天然适合分布式系统
2. 签名保证了客户端无法数据造假
3. 性能更高，不需要和中心状态服务器通讯，纯内存计算。

**JWT密钥是明文存储在客户端的**

### 生成密钥

``` C#
var claims = new List<Claim>(); // 要存储的数据集合
claims.Add(new Claim(ClaimTypes.Name, "shl")); // 用户名
claims.Add(new Claim(ClaimTypes.NameIdentifier, "111")); // 用户id
claims.Add(new Claim(ClaimTypes.Role, "admin")); // 角色
claims.Add(new Claim(ClaimTypes.Role, "user")); // 角色
claims.Add(new Claim("pa", "11223aads")); // 可以key
string key = "dasflkdsjflkdjsaf-823oiu2ojnljkndaspljfhknzxc-v0998"; // 密钥
DateTime expires = DateTime.Now.AddDays(1); // 过期时间
byte[] secBytes = Encoding.UTF8.GetBytes(key); // 将密钥转换为字节
var secKey = new SymmetricSecurityKey(secBytes);
var credentials = new SigningCredentials(secKey,SecurityAlgorithms.HmacSha256Signature);
var tokenDescriptor = new JwtSecurityToken(claims:claims,expires:expires,signingCredentials:credentials);
string jwt = new JwtSecurityTokenHandler().WriteToken(tokenDescriptor);
Console.WriteLine(jwt);
```

### 验证密钥

``` C#
/*
 不正规方式解码
using System.Text;

string jwt = Console.ReadLine()!;
string[] segments = jwt.Split('.');
string head = JwtDecode(segments[0]);
string payload = JwtDecode(segments[1]);
Console.WriteLine("--------head--------");
Console.WriteLine(head);
Console.WriteLine("--------payload--------");
Console.WriteLine(payload);
string JwtDecode(string s)
{
    s = s.Replace('-', '+').Replace('_', '/');
    switch (s.Length % 4)
    {
        case 2:
            s += "==";
            break;
        case 3:
            s += "=";
            break;
    }
    var bytes = Convert.FromBase64String(s);
    return Encoding.UTF8.GetString(bytes);
}*/
// 正规方式解码
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

string jwt = Console.ReadLine()!;
string secKey = "dasflkdsjflkdjsaf-823oiu2ojnljkndaspljfhknzxc-v099823"; // 密钥需要与生成时用的密钥一致
JwtSecurityTokenHandler tokenHandler = new();
TokenValidationParameters valParam = new();
var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secKey));
valParam.IssuerSigningKey = securityKey;
valParam.ValidateIssuer = false;
valParam.ValidateAudience = false;
ClaimsPrincipal claimsPrincipal = tokenHandler.ValidateToken(jwt,
        valParam, out SecurityToken secToken);
foreach (var claim in claimsPrincipal.Claims)
{
    Console.WriteLine($"{claim.Type}={claim.Value}");
}
```

**解码时如果令牌被客户端修改过会报错**

**解码时如果密钥不一致也会报错**

### ASP.NET WebAPI 中使用

**1. 引用包：`NuGet\Install-Package Microsoft.AspNetCore.Authentication.JwtBearer -Version 6.0.0`**

**2. 创建配置类和编写`appsettings.json`**

``` C#
public class JWTOption
{
    public string SigningKey { get; set; }
    public int ExpireSeconds { get; set; }
}
```

``` C#
"JWTOptions": {
  "SigningKey": "daslkfjopi2j3ljnlkjaasdopijlczxjniopjopi0392",
  "ExpireSeconds": 60
}
```

**3. `Program.cs`中注入**

``` C#
builder.Services.Configure<JWTOption>(builder.Configuration.GetSection("JWTOptions")); // 读取appsettings.json并转换为JWTOption类型
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) // 添加JWT
.AddJwtBearer(x =>
{
    var jwtOpt = builder.Configuration.GetSection("JWTOptions").Get<JWTOption>();
    byte[] keyBytes = Encoding.UTF8.GetBytes(jwtOpt.SigningKey);
    var secKey = new SymmetricSecurityKey(keyBytes);
    x.TokenValidationParameters = new()
    {
        ValidateIssuer = false,
        ValidateAudience = false,
        ValidateLifetime = true,
        ValidateIssuerSigningKey = true,
        IssuerSigningKey = secKey
    };
});
...
    

app.UseAuthentication(); // 中间件

app.UseAuthorization();
```

> `app.UseAuthentication();`需要在`app.UseAuthorization();`之前

**4. 登录生成令牌**

``` C#
[Route("api/[controller]/[action]")]
[ApiController]
public class LoginController : ControllerBase
{
    private IOptions<JWTOption> option;

    public LoginController(IOptions<JWTOption> option)
    {
        this.option = option;
    }

    [HttpPost]
    public ActionResult Log(string name,string pwd) // 登录成功生成JWT
    {
        if(name == "shl" && pwd == "123")
        {
            var claims = new List<Claim>();
            claims.Add(new Claim(ClaimTypes.Name, name));
            DateTime expires = DateTime.Now.AddSeconds(option.Value.ExpireSeconds);
            byte[] keyBytes = Encoding.UTF8.GetBytes(option.Value.SigningKey);
            var secKey = new SymmetricSecurityKey(keyBytes);
            var credentials = new SigningCredentials(secKey,
                SecurityAlgorithms.HmacSha256Signature);
            var tokenDescriptor = new JwtSecurityToken(expires: expires,
                signingCredentials: credentials, claims: claims);
            return Ok(new JwtSecurityTokenHandler().WriteToken(tokenDescriptor));
        }
        else
        {
            return BadRequest("登录失败");
        }
    }
}
```

**5. 其他控制器验证令牌**

``` C#
[Route("api/[controller]/[action]")]
[ApiController]
[Authorize] // 整个控制器必须登录了才能访问
public class HomeController : ControllerBase
{
    [HttpGet]
    public ActionResult Get1()
    {
        return Ok($"登录成功");
    }
    [HttpGet]
    [AllowAnonymous] // 该方法不验证令牌
    public ActionResult Get2()
    {
        return Ok("没登陆成功也可以访问n");
    }
    [HttpGet]
    [Authorize(Roles="admin")] // 验证令牌并且角色为admin
    public ActionResult Get3()
    {
        return Ok("只有角色为admin的可以访问");
    }
}
```

**6. 客户端访问**

1. 使用Postman工具时，需要请求头中带`Authorization`值为`Bearer 生成的令牌`

2. 在Swagger中需要添加如下代码，然后在点击Authorize设置令牌值为`Bearer 生成的令牌`就可以访问接口了

   ``` C#
   builder.Services.AddSwaggerGen(c =>
   {
       var scheme = new OpenApiSecurityScheme()
       {
           Description = "Authorization header. \r\nExample: 'Bearer 令牌'",
           Reference = new OpenApiReference
           {
               Type = ReferenceType.SecurityScheme,
               Id = "Authorization"
           },
           Scheme = "oauth2",
           Name = "Authorization",
           In = ParameterLocation.Header,
           Type = SecuritySchemeType.ApiKey,
       };
       c.AddSecurityDefinition("Authorization", scheme);
       var requirement = new OpenApiSecurityRequirement();
       requirement[scheme] = new List<string>();
       c.AddSecurityRequirement(requirement);
   });
   ```

### JWT撤回

JWT因为在服务器端没有存储任何值，所以如果服务器无法主动断开JWT，如果需要服务器主动让令牌失效，那么令牌就需要在服务器也存储一份或者在用户表中新增JWTVersion字段，每次生成JWT时带上版本号，然后可以判断版本号。

**登录页面生成JWT**

``` C#
[HttpPost]
public async Task<ActionResult> Login(UserLogin u) // 用户登录
{
    var user = await userManager.FindByNameAsync(u.userName); // 根据用户名查找用户
    if (user == null) // 用户不存在
    {
        return BadRequest("用户名或密码错误");
    }
    if (await userManager.IsLockedOutAsync(user)) // 用户是否被锁定
    {
        return BadRequest($"账户被锁定，解锁时间：{user.LockoutEnd}"); // 如果用户被锁定则提示用户已被锁定
    }
    if (await userManager.CheckPasswordAsync(user, u.paddword) == false) // 判断密码是否不正确
    {
        await userManager.AccessFailedAsync(user).IsOk(); // 标识此次登录失败
        return BadRequest("用户名或密码错误");
    }
    await userManager.ResetAccessFailedCountAsync(user).IsOk(); // 登录成功，重置登录失败次数

    user.JWTVersion++; // JWT版本
    await userManager.UpdateAsync(user); // 修改用户
    // 生成JWT
    var claims = new List<Claim>();
    claims.Add(new Claim(ClaimTypes.Name, user.UserName));
    claims.Add(new Claim("JWTVersion", user.JWTVersion.ToString()));
    DateTime expires = DateTime.Now.AddSeconds(options.Value.ExpireSeconds);
    byte[] keyBytes = Encoding.UTF8.GetBytes(options.Value.SigningKey);
    var secKey = new SymmetricSecurityKey(keyBytes);
    var credentials = new SigningCredentials(secKey,
                                             SecurityAlgorithms.HmacSha256Signature);
    var tokenDescriptor = new JwtSecurityToken(expires: expires,
                                               signingCredentials: credentials, claims: claims);
    return Ok("Bearer " + new JwtSecurityTokenHandler().WriteToken(tokenDescriptor));
}
```

**Filter中判断版本号是否过期**

``` C#
public class JWTFilter : IAsyncActionFilter
{

    private IMemoryCache memCache;
    private UserManager<MyUser> userMgr;

    public JWTFilter(IMemoryCache memCache, UserManager<MyUser> userMgr)
    {
        this.memCache = memCache;
        this.userMgr = userMgr;
    }

    public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
    {
        var claimUserName = context.HttpContext.User.FindFirst(ClaimTypes.Name); // 获取JWT中的名字
        if (claimUserName == null) // 如果用户名为空则说明此访问没有JWT令牌，进入下一个Filter
        {
            await next();
            return;
        }
        string userName = claimUserName.Value; 
        MyUser user = await memCache.GetOrCreateAsync("user_" + userName, async (c) => // 从缓存中取出用户信息
        {
            c.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(5);
            return await userMgr.FindByNameAsync(userName); // 从数据库中查找用户信息
        });
        if(user == null)
        {
            var result = new ObjectResult($"用户名{userName}不存在");
            result.StatusCode = (int)HttpStatusCode.NotFound;
            context.Result = result;
            return;
        }
        // 获取版本号
        var claimJWTVersion = context.HttpContext.User.FindFirst("JWTVersion");
        long jwtVersion = long.Parse(claimJWTVersion!.Value);
        if(jwtVersion >= user.JWTVersion) // 如果大于当前版本号则继续执行下一个Filter
        {
            await next();
        }
        else // 否则返回版本号过期
        {
            var result = new ObjectResult($"用户登录已过期");
            result.StatusCode = (int)HttpStatusCode.Unauthorized;
            context.Result = result;
            return;
        }
    } 

}
```

## 10.3 托管服务HostService

### 基本使用

托管服务应该实现`IHostedService`接口，一般编写继承自`BackgroundService`的类即可，因为`BackgroundService`已经继承了`IHostedService`

**1. 创建继承自`BackgroundService`的类**

``` C#
public class MyHostedService : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        Console.WriteLine("HostService启动");
        await Task.Delay(1000);
        Console.WriteLine("文件读取成功");
    }
}
```

**2. 在`Program.cs`中注入服务**

``` C#
builder.Services.AddHostedService<MyHostedService>();
```

托管服务中如果有**报错**息会导致整个ASP.NET Core WebAPI项目**停止**，如果想报错不停止项目可以在项目的`Program.cs`中添加如下代码

``` C#
builder.Services.Configure<HostOptions>(hostOptions =>
{
    hostOptions.BackgroundServiceExceptionBehavior = BackgroundServiceExceptionBehavior.Ignore;
});
```

### 托管服务中使用DI

托管服务是以**单例**的生命周期注入到依赖注入的容器中的，因此不能注入生命周期为范围或者瞬态的服务。

可以通过构造方法注入一个`IserviceScopeFactory`服务，它可以用来创建一个`IserviceScope`对象，这样我们就可以通过`IserviceScope`来创建短声明周期的服务了。需要在`Dispose`中释放`IServiceScope`对象

``` C#
public class MyHostedService : BackgroundService
{
    private readonly IServiceScope serviceScope; // 创建的IServiceScope

    public MyHostedService(IServiceScopeFactory serviceScopeFactory) // 注入IServiceScopeFactory
    {
        serviceScope = serviceScopeFactory.CreateScope(); // 通过注入的IServiceScopeFactory创建一个IServiceScope
    }
    public override void Dispose() // 释放IServiceScope对象
    {
        serviceScope.Dispose();
        base.Dispose();
    }


    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        Calculator c = serviceScope.ServiceProvider.GetRequiredService<Calculator>(); // 创建短声明周期的服务
        Console.WriteLine(c.Add(1, 1));
        Console.WriteLine("HostService启动");
        await Task.Delay(1000);
        //string s = null;
        //s.ToString();
        Console.WriteLine("文件读取成功");
    }
}
```

### 创建每隔5秒执行一次的任务

``` C#
public class TimeHostedService : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested) // 程序没结束就一直循环
        {
            Console.WriteLine("执行了一次");
            await Task.Delay(5000);
        }
    }
}
```

> 定时任务可以使用第三方包：`Hangfire`

## 10.4 数据校验

### 内置的数据校验

在实体类上加attribute

``` C#
public class UserVM
{
    [MinLength(3)] // 最小长度为3
    public string Name { get; set; }
    [Required] // 不能为空
    public string Email { get; set; }
    public string Password { get; set; }
    [Compare("Password")] //需要与Password内容一致
    public string CheckPassword { get; set; }
}
```

### 第三方包FluentValidation

安装包：`NuGet\Install-Package FluentValidation.AspNetCore -Version 11.3.0`

**1. 创建验证类**

``` C#
public class AddUserValidation : AbstractValidator<UserVM>
{
    public AddUserValidation()
    {
        RuleFor(x => x.Email).NotEmpty() // 不为空
            .EmailAddress() // 邮箱
            .WithMessage("请输入有效的邮箱！！！");
        RuleFor(x => x.Password).NotEmpty().Length(3, 10) // 密码不为空 长度为3到10
            .WithMessage("密码长度应该是3-10")
            .Equal(x => x.CheckPassword).WithMessage("两次密码不一致");
    }
}
public class UpdateUserValidation : AbstractValidator<UpdateUser>
{
    public UpdateUserValidation()
    {
        RuleFor(x => x.Name).NotEmpty().Length(3,5).WithMessage("用户名长度应为3-5");
        RuleFor(x => x.Phone).NotEmpty()
            .Must(c => c.StartsWith('1')) // 自定义验证条件
            .WithMessage("手机号验证不通过");
    }
}
```

**2. 在`Program.cs`中注册**

``` C#
builder.Services.AddValidatorsFromAssemblyContaining<AddUserValidation>(); // 注入与AddUserValidation类同一个数据集中所有继承了AbstractValidator的类
//builder.Services.AddFluentValidationAutoValidation();  // 默认也会支持内置数据校验
builder.Services.AddFluentValidationAutoValidation(config =>
{
    config.DisableDataAnnotationsValidation = true; // 取消对内置数据校验的支持
});
```

**在`AddUserValidation`类中可以使用依赖注入**

## 10.5 SignalR

**WebSocket**

1. WebSocket基于TCP协议，支持二进制通信，双工通信
2. 性能和并发能力更强
3. WebSocket独立于HTTP协议，不过我们一般仍然把WebSocket服务器端部署到Web服务器上，因为可以借助HTTP协议完成初始的握手（可选），并且共享HTTP服务器的端口（主要）。

**SignalR**

SignalR全称：ASP.NET Core SignalR，是.NET Core  平台对WebSocket的封装。

![image-20240809105756828](%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20240809105756828.png)

**Hub**（集线器），数据交换中心

### 第一个SignalR程序

**1. 新建一个ASP.NET Core WebAPI项目**

**2. 创建一个类继承自`Hub`**

> Hub 在 `Microsoft.AspNetCore.SignalR`命名空间下，WebAPI和MVC项目默认安装了`Microsoft.AspNetCore.SignalR`包只需要引用即可

``` C#
public class MyHub : Hub
{
    public Task PostServer(string msg) // 客户端向服务器发送数据的方法，方法名字可以自定义
    {
        string id = this.Context.ConnectionId; // 每个客户端都有单独的ID
        string res = $"{id}:{DateTime.Now}:{msg}";
        return this.Clients.All.SendAsync("SendPublicClient", res); // 服务器向客户端发送数据
    }
}
```

**3. `Program.cs`中注册并添加跨域**

``` C#
builder.Services.AddSignalR(); // 注册SignalR
builder.Services.AddCors(option => // 配置跨域
{
    option.AddPolicy("KuaYu", p =>
    {
        p.WithOrigins("http://localhost:5173") // 允许指定的域名
        .AllowAnyHeader() // 允许所有请求头
        .AllowAnyMethod() // 允许所有请求方法
        .AllowCredentials();
    });
});
var app = builder.Build();
app.UseCors("KuaYu"); // 启动跨域 
...
app.MapHub<MyHub>("/MyHub"); // SignalR的Map地址
```

> `app.MapHub<MyHub>("/MyHub");`必须在`app.MapControllers();`之前

**4. Vue中使用**

vue创建项目`npm create vue@latest`

vue需要安装包：`npm install @microsoft/signalr`

``` vue
<template>
  <input type="text" v-model="state.userMsg" v-on:keypress="txtMsgOnkey">
  <div>
    <ul>
      <li v-for="(msg,index) in state.messages" :key="index">{{ msg }}</li>
    </ul>
  </div>
</template>

<style>
</style>
<script>
import { reactive,onMounted } from "vue";
import * as signalR from "@microsoft/signalr";
let connection; // 创建连接
export default {
  setup() {
    const state = reactive({
      userMsg: "", // 用户输入的消息
      messages: [], // 接收的消息列表
    });
    const txtMsgOnkey = async function (e) { // 按下回车键发送消息
      if(e.keyCode != 13) return; // 不是回车键
      await connection.invoke("PostServer", state.userMsg); // 向服务器发送消息
      state.userMsg = "";
    }
    onMounted(async function () { // 页面加载完成后创建连接
      connection = new signalR.HubConnectionBuilder() // 创建连接
      .withUrl("https://localhost:7194/MyHub") // 指定连接地址
      .withAutomaticReconnect().build();
      await connection.start(); // 开始连接
      connection.on("SendPublicClient",msg=>{ // 接收消息
        state.messages.push(msg); // 添加到消息列表中
      })
    })
    return {
      state, 
      txtMsgOnkey
    }
  },
}
</script>
```



# 扩展学习

## 1. IDisposable 接口

实现了IDisposable接口的类会在离开using时自动调用Dispose方法

```C#
public class DisposeClass : IDisposable
{
    public string Name { get; set; }
    public void Dispose()
    {
        this.Name = "空";
        Console.WriteLine("注销了");
    }
}
```

使用代码：

```C#
DisposeClass d = null;
using(d = new DisposeClass()){
	d.Name = "zzz";
}
Console.WriteLine(d.Name);
```

运行结果：

```undefined
注销了
空
```

## 2. 扩展方法

### 2.1 概念

扩展方法是一种特殊类型的静态方法，对于一个C#类型，如类、值类型、接口等，扩展方法可以在不改变该类型源码的前提下，为它的实例提供新的成员。因此，若要为一个框架或第三方库的某个类型增加辅助功能，通过扩展方法就可以轻而易举的实现，这也是“扩展”的意义所在。

### 2.2 创建步骤

**1. 创建静态类**

**2. 在其中创建一个静态方法**

**3. 为这个静态方法添加至少一个参数，并且第一个参数前加上 `this` 关键字，这个关键字会告诉编译器当前方法是一个扩展方法。而这个方法将称为第一个参数所属类型的成员。**

**4. 将这个方法的命名空间改为跟所属类型同样的命名空间**

### 2.3 实例

**创建一个默认类**

``` C#
namespace SystemLog
{
    public class Test
    {
        public string Name { get; set; }
    }
}
```

**创建扩展方法类**

``` C#
namespace SystemLog
{
    public static class TestExtend
    {
        public static void MM(this Test test)
        {
            Console.WriteLine(test.Name);
        }
    }
}
```

**Main 调用**

``` C#
Test t = new Test();
t.Name = "Test";
t.MM();
```

## 3. 读取环境变量

使用类：`Environment`
使用方法：`GetEnvironmentVariable`
示例：

```C#
public string GetValue(string name)
{
    return Environment.GetEnvironmentVariable(name);
}
```

## 4. Static Using

``` C#
static using System.Linq.Expressions.Expression
```

> 使用static using 引用的类在方法中可以直接使用类中的方法，不需要再`类.方法`。类似于python的`from xxx import yy`

``` C#
var b = Parameter(
    typeof(Article),
    "b"
);

var e1 = Lambda<Func<Article,bool>>(
    GreaterThan(
        MakeMemberAccess(b,
            typeof(Article).GetProperty("Price")
        ),
        Constant(5.0)
    ),
    b
);
using (EFDBContent db = new EFDBContent())
{
    db.articles.Where(e1).ToArray();
}
```

## 5. C# 新语法

## .Net 6 

**随机数**

不用每次都`new Random().Next();`，这样有可能会导致每次的随即值都一样，可以用`Random.Shared.Next()`生成随机值，Shared是一个静态的Random类。

``` C#
int r = Random.Shared.Next();
```



### C# 8.0

**using语法** 

using 不带括号的方式表示在变量作用域结束时自动销毁变量。

``` C#
using FileStream f = File.OpenWrite("");
// 或 两种语法相同
using(FileStream f = File.OpenWrite("")){
    
}
```

**可空引用类型**

在项目文件（csproj）中，`<Nullable>enable</Nullable>`表示启用引用类型为空警告，如果引用类型为空值，则提示警告。

![image-20240729111937237](学习笔记.assets\image-20240729111937237.png)

去掉提示的方式：

``` C#
// 给变量设置为可控类型
public string? Name { get; set; }
// 给变量设置默认值
internal class Class1
{
    public string Name { get; set; }
    public string PName { get; set; }
    public Class1(string name,string pname)
    {
        this.Name = name;
        this.PName = pname;
    }
}
// 在使用时判断
if(class1.Name!= null)
{
    Console.WriteLine(class1.Name.ToLower());
}
// 在变量后加！强行去掉提示
Console.WriteLine(class1.Name!.ToLower());
```

**init初始赋值**

在类中，如果想声明一个属性只能在构造函数赋值一次，后面就不能给这个属性赋值了，可以使用init关键字

``` C#
public string n { get; init; }
```



### C# 9.0

**顶级语句**

创建顶级语句的项目，会跟python一样不用写类名就可以直接运行代码

**全局Using**

使用`global`关键字引用的命名空间，整个项目其他文件不需要引用，直接可以使用，可以创建一个新的文件，专门用来引用整个项目都需要使用到的命名空间

``` C#
global using System.Data.Common;
global using System.Net.Http;
```

在项目文件(csproj)中，`<ImplicitUsings>enable</ImplicitUsings>`表示将自动引用一些常用的命名空间，比如`System.IO`等。

**记录（record ）**

用`==`号可以判断两个对象的所有属性值是否一致而不是判断对象指向的地址是否是同一个

用`ToString()`可以输出类名加属性值

``` C#
// 声明一个记录 
namespace C_9
{
    internal record Class2(string Name,int Age);
}
```

``` C#
Class2 c1 = new Class2("sss", 18);
Class2 c2 = new Class2("sss", 18);
Console.WriteLine(c1.ToString()); // 输出 Class2 { Name = sss, Age = 18 }
Console.WriteLine(c1==c2); // True
```

记录后面跟的小括号里面的属性都是只读的，只有声明的时候可以赋值，其他时候不能赋值，如果想在记录里面声明可读可写的属性可以使用以下代码

``` C#
internal record Class2(string Name,int Age)
{
    public string NN { get; set; } // 此属性可读可写
}
// 记录名称后面的小括号可以省略，这样就变成了一个普通类的写法了，但是record的特性还都可以使用
internal record Class2
{
    public string NN { get; set; }
    public string NN2 { get; set; }
}
// 如果想使用不同的构造函数，可以使用以下代码
internal record Class2(string Name,int Age)
{
    public string NN { get; set; }
    public Class2(string name,int age,string nn)
        : this(name,age)
    {
        this.NN = nn;
    }
}
```

复制记录使用`with { 要修改的属性=修改值}`关键字，

``` C#
Class2 c1 = new Class2("sss", 18);
Class2 c3 = c1 with { };
Class2 c4 = c1 with { Age = 20 };
Console.WriteLine(c3.ToString()); // Class2 { Name = sss, Age = 18, NN =  }
Console.WriteLine(c4.ToString()); // Class2 { Name = sss, Age = 20, NN =  }
Console.WriteLine(c1==c3); // True
Console.WriteLine(c1==c4); // False
Console.WriteLine(object.ReferenceEquals(c1,c3)); // False
Console.WriteLine(object.ReferenceEquals(c1,c4)); // False
```



### C# 10

**取消namespace之后的大括号**

以下两种代码效果相同

```C#
namespace C_10
{
    internal class Class1
    {
    }
}

```

``` C#
namespace C_10;
internal class Class1
{
}
```

